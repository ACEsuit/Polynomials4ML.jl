var documenterSearchIndex = {"docs":
[{"location":"tutorials/#Tutorials-Index","page":"Tutorial Index","title":"Tutorials Index","text":"This is a preliminary list of tutorials for the P4ML package, generated using Literate.jl. The literate source can be found in Polynomials4ML.jl/tutorials/.\n\nPolynomial Regression","category":"section"},{"location":"SH/#Spherical-Harmonics","page":"Spherical and Solid Harmonics","title":"Spherical Harmonics","text":"This section provides documentation for the evaluation of complex and real spherical harmonics and solid harmonics, including gradient and Laplacian calculations. \n\nAssociated Legendre Polynomials\nComplex Spherical Harmonics\nComplex Solid Harmonics\nReal Spherical Harmonics\nReal Solid Harmonics","category":"section"},{"location":"SH/#Associated-Legendre-Polynomials","page":"Spherical and Solid Harmonics","title":"Associated Legendre Polynomials","text":"Associated Legendre polynomials P_ell^m are closely related to the spherical harmonics, P_ell^m of degree ell and order mgeq 0 are defined as (in the phase convention of Condon and Shortley)\n\n\tP_ell^m(x) = frac(-1)^m2^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell\n\nThe negative order can be related to the corresponding positive order via a proportionality constant that involves only ell and m, \n\nP_ell^-m(x) = (-1)^m frac(ell-m)(ell+m)P_ell^m(x) \n\nThe associated Legendre polynomials are orthogonal on the interval -1leq xleq 1 in the sense that \n\nint_-1^1 P_k^m(x) P_ell^m(x) mathrmdx = frac22ell+1frac(ell+m)(ell-m)delta_kell \n\nIn alp.jl, Polynomials4ML utilizes the following normalization for the associated Legendre polynomials,  \n\nbarP_ell^m(x) = sqrtfrac(2ell+1)(ell-m)2pi (ell+m)P_ell^m qquad mgeq 0\n\nand one can generate a data structure as \n\nALPs = ALPolynomials(maxL::Integer, T::Type=Float64)\n\nwhere maxL specifies the maximum degree of the polynomials. \n\nThe associated Legendre polynomials allow for \n\nP = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\n\nX is a point in spherical coordinates, P and dp stores P_l^m(X.cosθ) and dP_l^m(X.cosθ). Specifically, only non-negative m terms are stored, and are arranged in ell-major order. To retrieve the specific values of P_l^m and dP_l^m for given indices (l, m), one can use\n\nindex_p(l,m)\n\nThe algorithm for computing associated Legendre polynomials is based on Dusson(2022) eq.(A.7), where A_l^m, B_l^m, C_l^m can be found in Limpanuparb(2014) eq.(7)-(14). ","category":"section"},{"location":"SH/#Condon-Shortley-Sign-Convention","page":"Spherical and Solid Harmonics","title":"Condon-Shortley Sign Convention","text":"There are two sign conventions for associated Legendre polynomials. \n\nInclude the Condon-Shortley phase factor:\n\nP_ell^m(x) = frac(-1)^m2^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell\n\nExclude the Condon-Shortley phase factor:\n\nP_ell^m(x) = frac12^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell\n\nOne possible way to distinguish the two conventions is\n\nP_ell m(x) = (-1)^m P_ell^m(x) \n\nThe Condon-Shortley sign convention enables us to establish the following relationships between spherical harmonics and angular momentum ladder operators\n\nY_ell^m(theta varphi) = A_ell mhatL_-^ell-mY_ell^ell(theta varphi) \n\nY_ell^m(theta varphi) = A_ell -mhatL_+^ell+mY_ell^-ell(theta varphi) \n\nwith all positive constants A_ell m = sqrtfrac(ell+m)(2ell)(ell+m). Ignoring the Condon-Shortley phase would introduce signs into the A_ell m. It's only a sign convention. \n\nIncluding the factor of (-1)^m and written in terms x=costheta,  the first few associated Legendre polynomials are \n\nmbackslashell 0 1 2 3\n3    -15sin^3theta\n2   3sin^2theta 15costhetasin^2theta\n1  -sintheta -3sinthetacostheta -frac32(5cos^2theta - 1)sintheta\n0 1 costheta frac12(3cos^2theta - 1) frac12costheta(5cos^2theta-3)","category":"section"},{"location":"SH/#Complex-Spherical-Harmonics","page":"Spherical and Solid Harmonics","title":"Complex Spherical Harmonics","text":"In cylm.jl, Polynomials4ML utilizes orthonormalized complex spherical harmonics that includes the Condon-Shortley phase, defined as\n\n\tY_ell^m(theta varphi) = sqrtfrac2ell+14pifrac(ell-m)(ell+m)P_ell^m(cos theta)mathrme^mathrmim varphi \n\nThe normalization in complex spherical harmonics is chosen to satisfy\n\n\tint_0^2piint_0^piY_k^m(theta varphi)barY_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi =delta_kelldelta_mn\n\nOrthonormalized complex spherical harmonics that include the Condon-Shortley phase up to degree ell = 3 are\n\nmbackslashell 0 1 2 3\n3    -frac18sqrtfrac35picdot mathrme^3mathrmivarphicdot sin^3theta\n2   frac14sqrtfrac152picdot mathrme^2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^2mathrmivarphicdot sin^2thetacdot costheta\n1  -frac12sqrtfrac32picdot mathrme^mathrmivarphicdot sintheta -frac12sqrtfrac152picdot mathrme^mathrmivarphicdot sintheta cdot costheta -frac18sqrtfrac21picdot mathrme^mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n0 frac12sqrtfrac1pi frac12sqrtfrac3picdot cos theta frac14sqrtfrac5picdot (3cos^2theta - 1) frac14sqrtfrac7picdot (5cos^3theta - 3costheta)\n-1  frac12sqrtfrac32picdot mathrme^-mathrmivarphicdot sintheta frac12sqrtfrac152picdot mathrme^-mathrmivarphicdot sintheta cdot costheta frac18sqrtfrac21picdot mathrme^-mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n-2   frac14sqrtfrac152picdot mathrme^-2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^-2mathrmivarphicdot sin^2thetacdot costheta\n-3    frac18sqrtfrac35picdot mathrme^-3mathrmivarphicdot sin^3theta\n\nTo generate the complex spherical harmonics Y_ell^m with normalized associated Legendre polynomials barP_ell^m, the formulas can be rewritten as\n\nbegincases\nY_ell^0(theta varphi) = sqrtfrac12barP_ell^0(cos theta)\nY_ell^m(theta varphi) = sqrtfrac12barP_ell^m(cos theta)mathrme^mathrmim varphi\nY_ell^-m(theta varphi) = (-1)^mcdot sqrtfrac12 barP_ell^m(cos theta)mathrme^-mathrmim varphi\nendcases qquad m0\n\nTo evaluate the gradients of the spherical harmonics nabla Y_ell^m, one need to convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates, \n\nbegincases\n(fracpartial varphipartial x fracpartial varphipartial y fracpartial varphipartial z) = (-fracsinvarphirsin theta fraccosvarphirsin theta 0)\n(fracpartial thetapartial x fracpartial thetapartial y fracpartial thetapartial z) = (fraccos varphi cos thetar fracsin varphi cos thetar -fracsin thetar)\nendcases\n\nTherefore, the gradient of Y_ell^m can be expressed as,\n\nnabla Y_ell^m = fracmathrmim P_ell^m mathrme^mathrmimvarphirsin thetabeginbmatrix -sin varphi cos varphi 0 endbmatrix + \nfracpartial_thetaP_ell^m mathrme^mathrmimvarphirbeginbmatrix cos varphi cos thetasin varphicos theta -sintheta endbmatrix\n\nFor the sake of simplicity, we incorporated the coefficient in of P_ell^m into the term P_ell^m itself.\n\nTo ensure numerically stable evaluation of gradients near sin theta = 0, we compute P_ell^msin theta instead of P_ell^m. We refer to section A.1 of Dusson(2022) for detailed discussion.\n\nWe can further compute nabla^2 Y_ell^m as, \n\nnabla^2 Y_ell m = left(frac1r^2fracpartialpartial r r^2fracpartialpartial r - fracL^2r^2    right)Y_ell^m = -fracell(ell+1)r^2Y_ell^m\n\nOne can generate a data structure as \n\ncylm = CYlmBasis(maxL::Integer, T::Type=Float64)\n\nThe complex spherical harmonics allow for \n\nP = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\n\nTo retrieve the specific values of Y_l^m and dY_l^m for given indices (l, m), one can use\n\nindex_y(l,m)","category":"section"},{"location":"SH/#Alternative-normalizations-conventions","page":"Spherical and Solid Harmonics","title":"Alternative normalizations conventions","text":"Here, we provide a list of alternative normalizations conventions for complex spherical harmonics,\n\nSchmidt semi-normalized (Racah's normalization)\n\nC_ell^m(theta varphi) = sqrtfrac4pi2ell + 1Y_ell^m(theta varphi) = sqrtfrac(ell-m)(ell+m)P_ell^m(cos theta)mathrme^mathrmim varphi \n\nwith \n\nint_0^2piint_0^piC_k^m(theta varphi)barC_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi = frac4pi2ell + 1delta_kelldelta_mn \n\nIn this normalization, C_0^0(theta varphi) is equal to 1. \n\n4π-normalized\n\nmathscrY_ell^m (theta varphi) = sqrt4piY_ell^m(theta varphi) = sqrt(2ell+1)frac(l-m)(l+m)P_ell^m(cos theta)mathrme^mathrmim varphi \n\nwith \n\nint_0^2piint_0^pimathscrY_k^m(theta varphi)barmathscrY_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi = 4pidelta_kelldelta_mn ","category":"section"},{"location":"SH/#Complex-Solid-Harmonics","page":"Spherical and Solid Harmonics","title":"Complex Solid Harmonics","text":"In crlm.jl, Polynomials4ML utilizes orthonormalized complex solid harmonics defined as\n\n\tgamma_ell^m(r theta varphi) = r^ellY_ell^m(theta varphi) \n\ngamma_ell^m's are orthogonal is the sense that \n\n\tint_0^2piint_0^pigamma_k^m(theta varphi)bargamma_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi =delta_kelldelta_mnr^k+ell\n\nThe evaluation of solid harmonics can be obtained from the spherical harmonics by a simple scaling with r^ell.  To evaluate the gradients of the solid harmonics, nabla gamma_ell^m, the following expressions are used,\n\nbegincases\n(fracpartial rpartial x fracpartial rpartial y fracpartial rpartial z) = (sin theta cos varphisinthetasin varphi cos theta)\n(fracpartial varphipartial x fracpartial varphipartial y fracpartial varphipartial z) = (-fracsinvarphirsin theta fraccosvarphirsin theta 0)\n(fracpartial thetapartial x fracpartial thetapartial y fracpartial thetapartial z) = (fraccos varphi cos thetar fracsin varphi cos thetar -fracsin thetar)\nendcases\n\nTherefore, the gradient of gamma_ell^m can be expressed as,\n\nnabla gamma_ell^m = fracell r^ell P_ell^m mathrme^mathrmimvarphirbeginbmatrix sin theta cos varphi sinthetasin varphi cos theta endbmatrix+ fracmathrmim P_ell^m mathrme^mathrmimvarphirsin thetabeginbmatrix -sin varphi cos varphi 0 endbmatrix + \nfracpartial_thetaP_ell^m mathrme^mathrmimvarphirbeginbmatrix cos varphi cos thetasin varphicos theta -sintheta endbmatrix\n\nSimilarly, we incorporated the coefficient in of P_ell^m into the term P_ell^m itself. We can further compute nabla^2 gamma_ell^m as, \n\nnabla^2 r^ellY_ell m = left(frac1r^2fracpartialpartial r r^2fracpartialpartial r - fracL^2r^2    right)r^ellY_ell^m = fracY_ell mr^2fracpartialpartial rr^2fracpartial r^ellpartial r - fracr^ellL^2 Y_ell^mr^2 = 0\n\nthat is, the solid harmonics are solutions to Laplace's equation. ","category":"section"},{"location":"SH/#Real-Spherical-Harmonics","page":"Spherical and Solid Harmonics","title":"Real Spherical Harmonics","text":"In rylm.jl, Polynomials4ML utilizes orthonormalized real spherical harmonics that exclude the Condon-Shortley phase. \n\nInclude the Condon-Shortley phase factor:\n\nY_ell m(theta varphi)  = \nbegincases\nfracmathrmisqrt2(Y_ell^m - (-1)^m Y_ell^-m)  m  0\nY_ell^0  m = 0 \nfrac1sqrt2(Y_ell^-m + (-1)^m Y_ell^m)  m  0\nendcases = \nbegincases\n(-1)^m barP_ell^m(cos theta)sin(mvarphi)  m  0\nfrac1sqrt2 barP_ell^0(cos theta)  m = 0 \n(-1)^m barP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases\n\nExclude the Condon-Shortley phase factor:\n\nY_ell m(theta varphi) = \nbegincases\n-barP_ell^m(cos theta)sin(mvarphi)  m  0\nfrac1sqrt2 barP_ell^0(cos theta)  m = 0 \nbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases\n\nOrthonormalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are\n\nmbackslashell 0 1 2 3\n3    frac14sqrtfrac352picdot fracx(x^2-3y^2)r^3\n2   frac14sqrtfrac15picdot fracx^2-y^2r^2 frac14sqrtfrac105picdot frac(x^2-y^2)zr^3\n1  sqrtfrac34picdot fracxr frac12sqrtfrac15picdot fraczxr^2 frac14sqrtfrac212picdot fracx(5z^2-r^2)r^3\n0 frac12sqrtfrac1pi sqrtfrac34picdot fraczr frac14sqrtfrac5picdot frac3z^2-r^2r^2 frac14sqrtfrac7picdot fracz(5z^2-3r^2)r^3\n-1  sqrtfrac34picdot fracyr frac12sqrtfrac15picdot fracyzr^2 frac14sqrtfrac212picdot fracy(5z^2-r^2)r^3\n-2   frac12sqrtfrac15picdot fracxyr^2 frac12sqrtfrac105picdot fracxyzr^2\n-3    frac14sqrtfrac352picdot frac(3x^2-y^2)yr^3","category":"section"},{"location":"SH/#Real-Solid-Harmonics","page":"Spherical and Solid Harmonics","title":"Real Solid Harmonics","text":"In rrlm.jl, Polynomials4ML utilizes Schmidt semi-normalized real solid harmonics that exclude the Condon-Shortley phase.\n\nInclude the Condon-Shortley phase factor:\n\nS_ell m(r theta varphi)  = \nbegincases\nfracmathbbisqrt2left(C_ell m-(-1)^m C_ell-m right)  m  0\nC_10  m = 0 \n frac1sqrt2left(C_ell -m+(-1)^m C_ellmright)   m  0\nendcases = begincases\n(-1)^m sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)sin(mvarphi)  m  0\nsqrtfrac2pi2l+1barP_ell^0(cos theta)  m = 0 \n(-1)^m sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases\n\nwhere \n\nC_ell m(r theta varphi) = sqrtfrac4pi2ell + 1gamma_ell^m(theta varphi) \n\nwith \n\nint_0^2piint_0^piC_km(r theta varphi)barC_ell n(r theta varphi)sin theta mathrmdthetamathrmdvarphi = frac4pi2ell + 1delta_kelldelta_mn r^k+ell \n\nExclude the Condon-Shortley phase factor:\n\nS_ell m(r theta varphi)  = \nbegincases\n-sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)sin(mvarphi)  m  0\nsqrtfrac2pi2l+1barP_ell^0(cos theta)  m = 0 \nsqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases\n\nSchmidt semi-normalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are\n\nmbackslashell 0 1 2 3\n3    frac12sqrtfrac52(x^2-3y^2)x\n2   frac12sqrt3(x^2-y^2) frac12sqrt15(x^2-y^2)z\n1  x sqrt3xz frac12sqrtfrac32(5z^2-r^2)x\n0 1 z frac12(3z^2-r^2) frac12(5z^2-3r^2)z\n-1  y sqrt3yz frac12sqrtfrac32(5z^2-r^2)y\n-2   sqrt3xy sqrt15xyz\n-3    frac12sqrtfrac52(3x^2-y^2)y","category":"section"},{"location":"SH/#References","page":"Spherical and Solid Harmonics","title":"References","text":"Dusson, G., Bachmayr, M., Csányi, G., Drautz, R., Etter, S., van der Oord, C., & Ortner, C. (2022). Atomic cluster expansion: Completeness, efficiency and stability. Journal of Computational Physics, 454, 110946.\nHelgaker, T., Jorgensen, P., & Olsen, J. (2013). Molecular electronic-structure theory. John Wiley & Sons.\nLimpanuparb, T., & Milthorpe, J. (2014). Associated Legendre polynomials and spherical harmonics computation for chemistry applications. arXiv preprint arXiv:1410.1748.  \nWieczorek, M. A., & Meschede, M. (2018). SHTools: Tools for working with spherical harmonics. Geochemistry, Geophysics, Geosystems, 19(8), 2574-2592.","category":"section"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"This page lists all docstrings in Polynomials4ML.jl including for functions that are not part of the public API. Please check with the Public API which functionality for which we aim to guarantee semver-stability.","category":"section"},{"location":"docstrings/#Polynomials4ML.AbstractP4MLBasis","page":"Docstrings","title":"Polynomials4ML.AbstractP4MLBasis","text":"abstract type AbstractP4MLBasis end\n\nAnnotates types that map a low-dimensional input, scalar or SVector, to a vector of scalars (feature vector, embedding, basis...). Can be used  as a Lux layer. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CTrigBasis","page":"Docstrings","title":"Polynomials4ML.CTrigBasis","text":"Complex trigonometric polynomials up to degree N (inclusive). The basis is  constructed in the order \n\n[1, exp(im*θ), exp(-im*θ), exp(2im*θ), exp(-2im*θ), ..., \n                                exp(N*im*θ), exp(-N*im*θ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.ChebBasis","page":"Docstrings","title":"Polynomials4ML.ChebBasis","text":"ChebBasis(N): \n\nChebyshev polynomials up to degree N-1 (inclusive). i.e  basis with length N. The basis is ordered as \n\n1 x 2x^2-1 4x^3-3x  2xT_N-1(x)-T_N-2(x)\n\nwhere x is input variable. \n\nThe differences between ChebBasis and chebyshev_basis is that ChebBasis  computes the basis on the fly when it is compiled and it does not store the  recursion coefficients as in chebyshev_basis. There might be a small  performance benefit from this. \n\nSecondly, ChebBasis and chebyshev_basis use different normalization.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CubicSplines","page":"Docstrings","title":"Polynomials4ML.CubicSplines","text":"struct CubicSplines: \n\nStatically typed cubic splines, compatible with P4ML type batched evaluation.  For any P4ML basis with univariate input. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.MonoBasis","page":"Docstrings","title":"Polynomials4ML.MonoBasis","text":"Standard Monomials basis. This should very rarely be used. Possibly useful  in combination with a transformation of the inputs, e.g. exponential. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.OrthPolyBasis1D3T","page":"Docstrings","title":"Polynomials4ML.OrthPolyBasis1D3T","text":"OrthPolyBasis1D3T: defines a basis of polynomials in terms of a 3-term recursion, \n\nbeginaligned\n   P_1(x) = A_1  \n   P_2 = A_2 x + B_2 \n   P_n = (A_n x + B_n) P_n-1(x) + C_n P_n-2(x)\nendaligned\n\nTypically (but not necessarily) such bases are obtained by orthogonalizing the monomials with respect to a user-specified distribution, which can be either continuous or discrete but must have a density function. See also \n\nlegendre_basis\nchebyshev_basis\njacobi_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.RTrigBasis","page":"Docstrings","title":"Polynomials4ML.RTrigBasis","text":"RTrigBasis(N): \n\nReal trigonometric polynomials up to degree N (inclusive). The basis is ordered as \n\n[1, cos(θ), sin(θ), cos(2θ), sin(2θ), ..., cos(Nθ), sin(Nθ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.StaticBatch","page":"Docstrings","title":"Polynomials4ML.StaticBatch","text":"StaticBatch{N,T} : an auxiliary StaticArray type that is distinct from  SVector{N,T}. It can be used to create a batch of inputs of static size N.  It is in used to convert function calls with single inputs to function calls  with a batch of inputs. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.TransformedBasis","page":"Docstrings","title":"Polynomials4ML.TransformedBasis","text":"struct TransformedBasis\n\nBasically a two-stage chain, consisting of an input transformation,  and basis evaluation. Constructor: \n\nTransformedBasis(trans, basis)\n\nThe point of this structure is to provide a transformed basis that  behaves exactly as all other P4ML bases. \n\nComments\n\nthe \"natural indices\" will be the same as for basis\n_generate_input is not implemented for general input transforms; to \n\nimplement it for an input transform of type TIN one should monkey-patch \n\nPolynomials4ML._generate_input(::TransformedBasis{TIN}, T::Type) where {TIN} = ...\n\n_valtype is implemented but unclear how well it behaves, might be necessary \n\nto monkey-patch it as well\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.WrappedBasis","page":"Docstrings","title":"Polynomials4ML.WrappedBasis","text":"struct WrappedBasis \n\nA wrapper type for a Lux layer l that behaves like a P4ML basis. The wrapper  implements the necessary methods to make WrappedBasis a valid AbstractP4MLBasis. It assumes that the following calls are valid: \n\nl(x::T, ps, st) with T <: Number produces an AbstractVector{T}; i.e. \nl(X::AbstractVector{T}, ps, st) produces an B::AbstractMatrix{T} of \n\nnumbers, with B[i, :] == l(X[i], ps, st).\n\nIn particular it is assume that input and output types match. If this  fails then the behaviour is undefined. (With the non-allocating interface  this is likely unproblematic. Witht he allocating interface one could  monkey-patch _valtype to get around this restriction.)\n\nThe forwardpass is computed via l(x, ps, st). Due to the above assumption,  the optimal implementation of derivatives is forward-mode, hence evaluate_ed is implemented via ForwardDiff, and the rrule is provided by the standard P4ML  interface. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML._eval_cubic-NTuple{5, Any}","page":"Docstrings","title":"Polynomials4ML._eval_cubic","text":"evalcubic(t, fl, fr, gl, gr, h)\n\nEvaluate cubic spline at position t in [0,1], given function values fl, fr and gradients gl, gr at the left and right endpoints.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML._eval_cubspl-NTuple{6, Any}","page":"Docstrings","title":"Polynomials4ML._eval_cubspl","text":"evalcubspl(x, F, G, x0, x1, NX)\n\nauxiliary function to the evaluate the cubic spline basis given  the spline data arrays    \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML._generate_input","page":"Docstrings","title":"Polynomials4ML._generate_input","text":"generateinput(basis)\n\nReturns a single randomly generated valid input for basis. \n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Polynomials4ML._gradtype","page":"Docstrings","title":"Polynomials4ML._gradtype","text":"_gradtype(basis, x)\n\nIf the intention is that P, dP = evaluate_ed(basis, x) then  then _gradtype(basis, x) should return etype(dP). \n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}","page":"Docstrings","title":"Polynomials4ML._init_luxparams","text":"a fall-back method for initalparameters that all AbstractP4MLBasis should overload \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML._valtype","page":"Docstrings","title":"Polynomials4ML._valtype","text":"_valtype(basis, x) \n\nIf the intention is that P = basis(x) where P is a Vector{T}  then _valtype(basis, x) should return T. \n\nHere, x can be a single input, a batch or a type. A new basis type TB only  needs to implement _valtype(::TB, x::Type). \n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Polynomials4ML.chebyshev_basis-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.chebyshev_basis","text":"chebyshev_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Chebyshev polynomials of the first kind. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.complex_solidharmonics-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.complex_solidharmonics","text":"complex_solidharmonics(L; kwargs...)\n\nGenerate a complex solid harmonics basis (wrapper of sphericart implementation)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.complex_sphericalharmonics-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.complex_sphericalharmonics","text":"complex_sphericalharmonics(L; kwargs...)\n\nGenerate a complex spherical harmonics basis (wrapper of sphericart implementation)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.construct_basis-Tuple{Any, Any, Polynomials4ML.AbstractDecayFunction, Any}","page":"Docstrings","title":"Polynomials4ML.construct_basis","text":"construct_basis(RadialDecay, ζ_raw, D_raw, decay)\n\nConstruct a RadialDecay object from raw matrix data ζ_raw, D_raw  and a DecayFunction(f, df) representing the decay form and its derivative. All input is converted to statically-sized SMatrix for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.index","page":"Docstrings","title":"Polynomials4ML.index","text":"index(basis, k) -> Integer\n\nGiven a \"natural description\" of a basis element return the index of that basis  element in the computed vector of basis function values. For example, for  Chebyshev polynomials, index(basis, n) returns n+1. \n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Polynomials4ML.jacobi_basis-Tuple{Integer, Real, Real}","page":"Docstrings","title":"Polynomials4ML.jacobi_basis","text":"jacobi_basis(N::Integer, α::Real, β::Real): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Jacobi polynomials Jαβ. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.legendre_basis-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.legendre_basis","text":"legendre_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Legendre polynomials (L2 orthonormal on [-1, 1]). N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.natural_indices","page":"Docstrings","title":"Polynomials4ML.natural_indices","text":"natural_indices(basis) -> AbstractVector\n\nReturns an abstract vector of \"natural\" descriptions of the basis functions in  the order that they are stored in the computed vector of basis function values. For example, for Chebyshev polynomials, natural_indices(basis) returns  0:N, where N+1 is the length of the basis. For Spherical Harmmonics,  a natural description requires two indices (l, m), so the output will be a  vector of tuples.\n\nAt the moment, this function is used only for inspection and testing so no  strict format is enforced.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#Polynomials4ML.orthpolybasis-Union{Tuple{TW}, Tuple{Integer, Polynomials4ML.DiscreteWeights{TW}}} where TW","page":"Docstrings","title":"Polynomials4ML.orthpolybasis","text":"function orthpolybasis(...) : construct a univariate orthogonal polynomial  basis with respect to some specified inner product. For the standard 3-term  recursion polynomials, use legendre_basis, jacobi_basis or chebyshev_basis. \n\nThe orthpolybasis currently implements orthogonal polynomials for discrete weights with the following constructors: \n\northpolybasis(N::Integer, W::DiscreteWeights{TW}; TX = Float64)\northpolybasis(N::Integer, X::AbstractVector{<: Real}, \n              W::AbstractVector{<: Real}, normalizeW=false; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.real_solidharmonics-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.real_solidharmonics","text":"real_solidharmonics(L; kwargs...)\n\nGenerate a real solid harmonics basis (wrapper of sphericart implementation)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.real_sphericalharmonics-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.real_sphericalharmonics","text":"real_sphericalharmonics(L; kwargs...)\n\nGenerate a real spherical harmonics basis (wrapper of sphericart implementation)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.splinify-NTuple{4, Any}","page":"Docstrings","title":"Polynomials4ML.splinify","text":"splinify(basis, x0, x1, NX; bspline=true)\n\nTakes a P4ML basis with univariate input and constructs a cubic spline basis  that interpolates the basis functions on a uniform grid with NX nodes.  If bspline=true (default) the function values are first interpolated onto a B-spline representation to obtain C2,2 regularity of the splines. \n\nx0, x1 are the left and right endpoints of the spline interval. \n\nThis is currently not exported and not part of the public interface. The  interface can change in future releases.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.Utils.LinL","page":"Docstrings","title":"Polynomials4ML.Utils.LinL","text":"struct LinL\n\nA very basic linear layer that is compatible with the memory layout  of P4ML.       \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.Utils._gensparse-Union{Tuple{NU}, Tuple{Val{NU}, Vararg{Any, 7}}} where NU","page":"Docstrings","title":"Polynomials4ML.Utils._gensparse","text":"_gensparse : function barrier for gensparse\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.Utils.gensparse-Tuple{}","page":"Docstrings","title":"Polynomials4ML.Utils.gensparse","text":"gensparse(...) : utility function to generate high-dimensional sparse grids which are downsets. All arguments are keyword arguments (with defaults):\n\nNU : maximum correlation order\nminvv = 0 : minvv[i] gives the minimum value forvv[i]`\nmaxvv = Inf : maxvv[i] gives the minimum value forvv[i]`\ntup2b = vv -> vv :\nadmissible = _ -> false : determines whether a tuple belongs to the downset\nfilter = _ -> true : a callable object that returns true of tuple is to be kept and\n\nfalse otherwise (whether or not it is part of the downset!) This is used, e.g. to enfore conditions such as ∑ lₐ = even or |∑ mₐ| ≦ M\n\nINT = Int : integer type to be used\nordered = false : whether only ordered tuples are produced; ordered tuples\n\ncorrespond to  permutation-invariant basis functions\n\n\n\n\n\n","category":"method"},{"location":"lux/#Lux-Integration","page":"Lux Integration","title":"Lux Integration","text":"","category":"section"},{"location":"lux/#Internals","page":"Lux Integration","title":"Internals","text":"There is a default \n\n_evaluate!(P, dP, basis, X) = _evaluate!(P, dP, basis, X, nothing, nothing) \n\nThis assumes that the basis has no parameters and no state other than  frozen hyperparameters stored in basis itself. If basis does have parameters  and or state, then it should overload this call. For example, \n\nstruct LearnableCheb{N, SW} <: AbstractP4MLBasis \n   cheb::ChebBasis{N}\n   W::SW   # store as SMatrix!!!\nend\n\n# the following \"transfer\" to a different method with explicit parameters \n# is zero-cost! \n\n_evaluate!(P, dP, basis, X) = \n      _evaluate!(P, dP, basis, X, (W = basis.W,), NamedTuple())\n\nfunction _evaluate!(P, dP, basis, X, ps, st)\n   T, dT = evaluate_ed(basis.cheb) \n   mul!(P, ps.W, T)\n   isnothing(dP) || mul!(dP, ps.W, dT)   \n   return nothing \nend","category":"section"},{"location":"benchmarking/#Benchmark-Instructions","page":"Benchmark Instructions","title":"Benchmark Instructions","text":"For general reference look BenchmarkTools manual.\n\nA simple way to run benchmarks is to call\n\nusing BenchmarkTools\nusing PkgBenchmark\nusing Polynomials4ML\n\nbench = benchmarkpkg(Polynomials4ML)\nresults = bench.benchmarkgroup\n\n# You can search with macro \"@tagged\"\nresults[@tagged \"derivative\" && \"Chebyshev\"]\n\nYou can create BenchmarkConfig to control benchmark\n\nt2 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 2))\nbench_t2 = benchmarkpkg(Polynomials4ML, t2)\n\nBenchmarks can be save to a file with\n\nexport_markdown(\"results.md\", bench)\n\nComparing current branch to another branch\n\n# current branch to \"origin/main\"\nj = judge(Polynomials4ML, \"origin/main\")\n\nBenchmark scaling to different amount of threads\n\nt4 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 4))\nt8 = BenchmarkConfig(env = Dict(\"JULIA_NUM_THREADS\" => 8))\n\n# Compare how much changing from 4-threads to 8 improves the performance\nj = judge(Polynomials4ML, t8, t4)\n\nshow(j.benchmarkgroup)","category":"section"},{"location":"benchmarking/#CI-Benchmarks","page":"Benchmark Instructions","title":"CI Benchmarks","text":"Benchmarks can be run automatically on PR's by adding label \"run benchmark\" to the PR.","category":"section"},{"location":"benchmarking/#Adding-more-benchmarks","page":"Benchmark Instructions","title":"Adding more benchmarks","text":"Take a look at benchmark/benchmarks.jl for an example. If your benchmark depends on an additional packages you need to add the package to benchmark/Project.toml.","category":"section"},{"location":"literate_tutorials/polyregression/#Linear-Polynomial-Regression","page":"Linear Regression","title":"Linear Polynomial Regression","text":"This tutorial show how to use the P4ML package to perform a naive polynomial regression. This is not really the intended use-case of the package, but it serves to illustrate some basic usage and functionality.\n\nusing Polynomials4ML, LinearAlgebra, StaticArrays","category":"section"},{"location":"literate_tutorials/polyregression/#Example-1:-Univariate-Polynomial-Regression","page":"Linear Regression","title":"Example 1: Univariate Polynomial Regression","text":"First, we specify a target function, which we will try to approximate.\n\nf1(x) = 1 / (1 + 10 * x^2);\nnothing #hide\n\nSuppose we are given data in the form of argument, function value pairs, with arguments sampled uniformly from the interval [-1, 1].\n\nN = 1_000\nXtrain = 2 * rand(N) .- 1\nYtrain = f1.(Xtrain);\nnothing #hide\n\nWe want to solve the least squares problem\n\n  min_p sum_i = 1^N  y_i - p(x_i) ^2\n\nfor a polynomial p. Because f_1 is analytic, we use a degree approximately sqrtN. Since the distribution of the samples is uniform, the Legrendre polynomials are likely a good choice.\n\nbasis = legendre_basis(ceil(Int, sqrt(N)))\nc = basis(Xtrain) \\ Ytrain\np = x -> sum(c .* basis(x));\nnothing #hide\n\nA quick statistical test error\n\nXtest = 2 * rand(N) .- 1\nYtest = f1.(Xtest)\nprintln(\"Test RMSE: \", norm(Ytest - p.(Xtest)) / sqrt(N))","category":"section"},{"location":"literate_tutorials/polyregression/#Example-2:-Polynomial-Regression-on-the-Sphere","page":"Linear Regression","title":"Example 2: Polynomial Regression on the Sphere","text":"As a second example we consider a function defined on the unit sphere,\n\nf2(x) = 1 / (1 + 10 * norm(x - SA[1.0,0.0,0.0])^2);\nnothing #hide\n\nwhere x is now an SVector{3, Float64} with norm(x) == 1. We generate again uniform samples on the sphere.\n\nN = 1_000\nX = [ (x = randn(SVector{3, Float64}); x/norm(x)) for i = 1:N ]\nY = f2.(X);\nnothing #hide\n\nIn this case, spherical harmonics are natural basis functions. P4ML implements both real and complex spherical harmonics. Since the target function is real, we choose the real basis.\n\nbasis = real_sphericalharmonics(9)\n@show length(basis);\nnothing #hide\n\nWe see that we now have far more basis functions per degree and therefore cannot use as high a degree as before (unless we give ourselves more data). Otherwise we can proceed exactly as above.\n\nc = basis(X) \\ Y\np = x -> sum(c .* basis(x));\nnothing #hide\n\nWe can test the RMSE again.\n\nXtest = [ (x = randn(SVector{3, Float64}); x/norm(x)) for i = 1:N ]\nYtest = f2.(Xtest)\nprintln(\"Test RMSE: \", norm(Ytest - p.(Xtest)) / sqrt(N));\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"polynomials/#API-for-Polynomial-Bases","page":"Bases / Embeddings","title":"API for Polynomial Bases","text":"This page documents the public API for polynomial bases: the list of bases and functions that are considered relatively stable and for which we aim to strictly impose semver backward compatibility. The basis sets that are considered stable are the following (please see inline documentation for initialization): \n\nSeveral classes of orthogonal polynomials OrthPolyBasis1D3T\nGeneral Jacobi jacobi_basis\nLegendre legendre_basis\nChebyshev chebyshev_basis\nDiscrete distribution orthpolybasis \nAlternative implementation of Chebyshev polynomials of the first kind ChebBasis\n2D harmonics: \nComplex trigonometric polynomials CTrigBasis\nReal trigonometric polynomials RTrigBasis\n3D harmonics: \nComplex spherical harmonics complex_sphericalharmonics\nReal spherical harmonics real_sphericalharmonics\nComplex solid harmonics complex_solidharmonics\nReal solid harmonics real_solidharmonics","category":"section"},{"location":"polynomials/#In-place-Evaluation","page":"Bases / Embeddings","title":"In-place Evaluation","text":"This section documents the in-place evaluation interface. The polynomial basis sets implemented in this package should provide this interface as a minimal requirement. Because these mappings are all low-to-high dimensional, and are almost never a computational bottleneck, we do not current support pullbacks and pushforwards but only classical evaluation and point-wise differentiation, for either single inputs or batches of inputs. \n\nevaluate!(P, basis, X)\nevaluate_ed!(P, dP, basis, X)\nevaluate_ed2!(P, dP, ddP, basis, X)\n\nbasis : an object defining one of the basis sets \nX : a single input or array of inputs. \nP : array containing the basis values \ndP : array containing derivatives of basis w.r.t. inputs \nddP : array containing second derivatives of basis w.r.t. inputs \n\nIf X is a single input then this should normally be a Number or a StaticArray to distinguish it from collections of inputs. X can also be an AbstractArray of admissible inputs, e.g., Vector{<: Number}. \n\nIf X is a single input then P, dP, ddP will be AbstractVector. If X is an AbstractVector of inputs then P, dP, ddP must be AbstractMatrix, and so forth. \n\nThe output arrays P, dP, ddP must be sufficiently large in each dimension to accomodate the size of the input and the size of the basis, but the sizes need not match exactly. It is up to the caller to ensure matching array sizes if this is needed.","category":"section"},{"location":"polynomials/#Allocating-Evaluation","page":"Bases / Embeddings","title":"Allocating Evaluation","text":"This section documents the allocating evaluation interface. All basis sets should implement this interface.\n\nP = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\nP, dP, ddP = evaluate_ed2(basis, X)\n\nThe output types of P, dP, ddP are guaranteed to be AbstractArrays but may otherwise change between package versions. The exact type should not be relied upon when using this package.\n\nThe meaning of the different symbols is exactly the same as described above. The only difference is that the output containers P, dP, ddP are now allocated.  Their type should be stable (if not, please file a bug report), but unspecified in the sense that the output type is not semver-stable for the time being.  If you need a sem-ver stable output then it is best to follow the above with a collect or to wrap the non-allocation versions. ","category":"section"},{"location":"polynomials/#Using-the-WithAlloc.jl-Bumper-extension","page":"Bases / Embeddings","title":"Using the WithAlloc.jl Bumper extension","text":"The package WithAlloc introduces a function whatalloc that allows one to specify the output arrays required for an in-place evaluation. It furthermore provides a macro @withalloc to wrap this functionality conveniently. For example, \n\n@no_escape begin \n   basis = legendre_basis(10) \n   X = 2 * rand(100) .- 1\n   P1 = @withalloc evaluate!(basis, X)\n   P2, dP2 = @withalloc evaluate_ed!(basis, X)\n   ;\nend \n\nThe arrays P1, P2, dP2 are Bumper-allocated i.e. are not allowed to leave the no-escape block. Please see [WithAlloc.jl](https://github.com/ACEsuit/WithAlloc.jl) and [Bumper.jl](https://github.com/MasonProtter/Bumper.jl) for more details. If output arrays are to be used outside of the local scope then the allocating functions evaluate, evaluate_ed etc, should be used or array allocation managed differently. ","category":"section"},{"location":"polynomials/#Utility-functions","page":"Bases / Embeddings","title":"Utility functions","text":"The basis specification can be obtained using Polynomials4ML.natural_indices\n\nspec = natural_indices(basis)\n\nThis produces a Vector{<: NamedTuple}; e.g., for a Chebyshev basis it will be of the form \n\nspec == [ (n = 0,), (n = 1,), ... ] \n\nwhile for spherical or solid harmonics, it will be of the form \n\nspec == [ (l = 0, m = 0), (l = 1, m = -1), (l = 1, m = 0), ... ]","category":"section"},{"location":"api/#Public-API","page":"API Index","title":"Public API","text":"The following pages document the public API for which we aim to provide strict semver compatibility. \n\nPages = [\"polynomials.md\", \"integration.md\",]\nDepth = 2","category":"section"},{"location":"integration/#ChainRules","page":"Integration","title":"ChainRules","text":"We aim to provide ChainRules.jl integration for all model components. At present, we have focused on providing the rrule interface. If basis is a polynomial basis then one can obtain its value and pullback via the ChainRules.jl interface, \n\nB, pb = rrule(evaluate, basis, X)\nB, dP, pb = rrule(evaluate_ed, basis, X)\n\nInternally, the pullback pb will most likely call a custom implementation of the pullback operation.\n\nIf any rrules are missing or not working as expected, please file an issue. ","category":"section"},{"location":"background/#Background","page":"Background Index","title":"Background","text":"The following pages explain some of the mathematical background and/or conventions of the models implemented in P4ML.\n\nPages = [\"SH.md\",  ]\nDepth = 2","category":"section"},{"location":"#Polynomials4ML.jl","page":"Home","title":"Polynomials4ML.jl","text":"Documentation for Polynomials4ML.\n\nPages = [\"api.md\", \"polynomials.md\", \"integration.md\",  \"tutorials.md\", \"background.md\", \"SH.md\", \"docstrings.md\", ]\nDepth = 2","category":"section"}]
}
