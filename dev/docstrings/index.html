<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Polynomials4ML.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ACEsuit.github.io/Polynomials4ML.jl/docstrings/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Polynomials4ML.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Tutorial Index</a></li><li><a class="tocitem" href="../literate_tutorials/polyregression/">Linear Regression</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../SH/">Spherical Harmonics</a></li><li><a class="tocitem" href="../ace/">Cluster Expansion</a></li></ul></li><li class="is-active"><a class="tocitem" href>Docstrings</a></li><li><a class="tocitem" href="../experimental/">Experimental</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/main/docs/src/docstrings.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><p>This page lists <em>all</em> docstrings in <code>Polynomials4ML</code> including for functions that are not part of the public API. Please check with the <a href="../api/#Public-API">Public API</a> which functionality for which we aim to guarantee semver-stability.</p><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.ALPolynomials" href="#Polynomials4ML.ALPolynomials"><code>Polynomials4ML.ALPolynomials</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ALPolynomials</code> : an auxiliary datastructure for evaluating the associated Legendre functions used for the spherical and solid harmonics. Constructor:</p><pre><code class="language-julia hljs">ALPolynomials(maxL::Integer, T::Type=Float64)</code></pre><p>This is not part of the public API and not guaranteed to be semver-stable. Only the resulting harmonics that use the ALPs are guaranteed to be backward  compatible. </p><p>Important Note: <code>evaluate_ed!</code>` does NOT return derivatives, but rather  produces rescaled derivatives for better numerical stability near the poles.  See comments in code for details on how to use the ALP derivatives correctly. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/alp.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.CRlmBasis" href="#Polynomials4ML.CRlmBasis"><code>Polynomials4ML.CRlmBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>complex spherical harmonics: </p><p>Yₗ⁰(θ, φ) = P̄ₗ⁰(cosθ)/√2 Yₗᵐ(θ, φ) = P̄ₗᵐ(cosθ)exp(imφ)/√2 Yₗ⁻ᵐ(θ, φ) = (-1)ᵐ P̄ₗᵐ(cosθ)/√2 exp(-imφ)</p><p>solid harmonics:</p><p>γₗᵐ(r, θ, φ) = rˡYₗᵐ(θ, φ)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/crlm.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.CTrigBasis" href="#Polynomials4ML.CTrigBasis"><code>Polynomials4ML.CTrigBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Complex trigonometric polynomials up to degree <code>N</code> (inclusive). The basis is  constructed in the order </p><pre><code class="nohighlight hljs">[1, exp(im*θ), exp(-im*θ), exp(2im*θ), exp(-2im*θ), ..., 
                                exp(N*im*θ), exp(-N*im*θ) ]</code></pre><p>where <code>θ</code> is input variable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/trig.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.CYlmBasis" href="#Polynomials4ML.CYlmBasis"><code>Polynomials4ML.CYlmBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>CYlmBasis(maxL, T=Float64):</code></p><p>Complex spherical harmonics; see tests to see how they are normalized, and  <code>idx2lm</code> on how they are ordered. The ordering is not guarenteed to be semver-stable.</p><p>The input variable is normally an <code>rr::SVector{3, T}</code>. This <code>rr</code> need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when <code>norm(rr) != 1</code>.</p><ul><li><code>maxL</code> : maximum degree of the spherical harmonics</li><li><code>T</code> : type used to store the coefficients for the associated legendre functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/cylm.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.ChebBasis" href="#Polynomials4ML.ChebBasis"><code>Polynomials4ML.ChebBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ChebBasis(N)</code>: </p><p>Chebyshev polynomials up to degree <code>N-1</code> (inclusive). i.e  basis with length <code>N</code>. The basis is ordered as </p><p class="math-container">\[[1, x, 2x^2-1, 4x^3-3x, ..., 2xT_{N-1}(x)-T_{N-2}(x)]\]</p><p>where <code>x</code> is input variable. </p><p>The differences between <code>ChebBasis</code> and <code>chebyshev_basis</code> is that <code>ChebBasis</code> computes the basis on the go when it is compiled and it does not store the recursion coefficients as in <code>chebyshev_basis</code>.</p><p>Warning: <code>ChebBasis</code> and <code>chebyshev_basis</code> have different normalization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/chebbasis.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.LinearLayer" href="#Polynomials4ML.LinearLayer"><code>Polynomials4ML.LinearLayer</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct LinearLayer</code> : This lux layer returns <code>W * x</code> if <code>feature_first</code> is true, otherwise it returns <code>x * transpose(W)</code>, where <code>W</code> is the weight matrix` where </p><ul><li><code>x::AbstractMatrix</code> of size <code>(in_dim, N)</code> or <code>(N, in_dim)</code>, where <code>in_dim = feature dimension</code>, <code>N = batch size</code></li><li><code>W::AbstractMatrix</code> of size <code>(out_dim, in_dim)</code></li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LinearLayer(in_dim, out_dim; feature_first = false)</code></pre><p>For example</p><pre><code class="language-julia hljs">in_d, out_d = 4, 3 # feature dimensions
N = 10 # batch size

# feature_first = true
l = P4ML.LinearLayer(in_d, out_d; feature_first = true)
ps, st = LuxCore.setup(MersenneTwister(1234), l)
x = randn(in_d, N) # feature-first
out, st = l(x, ps, st)
println(out == W * x) # true

# feature_first = false
l2 = P4ML.LinearLayer(in_d, out_d; feature_first = true)
ps2, st2 = LuxCore.setup(MersenneTwister(1234), l2)
x = randn(N, in_d) # batch-first
out, st = l(x, ps, st)
println(out == x * transpose(W))) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/linear.jl#L6-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.MonoBasis" href="#Polynomials4ML.MonoBasis"><code>Polynomials4ML.MonoBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Standard Monomials basis. This should very rarely be used. Possibly useful in combination with a transformation of the inputs, e.g. exponential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/monomials.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.OrthPolyBasis1D3T" href="#Polynomials4ML.OrthPolyBasis1D3T"><code>Polynomials4ML.OrthPolyBasis1D3T</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>OrthPolyBasis1D3T:</code> defines a basis of polynomials in terms of a 3-term recursion, </p><p class="math-container">\[\begin{aligned}
   P_1(x) &amp;= A_1  \\
   P_2 &amp;= A_2 x + B_2 \\
   P_{n} &amp;= (A_n x + B_n) P_{n-1}(x) + C_n P_{n-2}(x)
\end{aligned}\]</p><p>Typically (but not necessarily) such bases are obtained by orthogonalizing the monomials with respect to a user-specified distribution, which can be either continuous or discrete but must have a density function. See also </p><ul><li><code>legendre_basis</code></li><li><code>chebyshev_basis</code></li><li><code>jacobi_basis</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/orthopolybasis.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.PooledSparseProduct" href="#Polynomials4ML.PooledSparseProduct"><code>Polynomials4ML.PooledSparseProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct PooledSparseProduct</code> :  This implements a fused (tensor) product and pooling operation. Suppose  we are given <span>$N$</span> embeddings <span>$\phi^{(i)}_{k_i}$</span> then the pooled sparse product  generates feature vectors of the form </p><p class="math-container">\[A_{k_1, \dots, k_N} = \sum_{j} \prod_{t = 1}^N \phi^{(t)}_{k_t}(x_j)\]</p><p>where <span>$x_j$</span> are an list of inputs (multi-set). </p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PooledSparseProduct(spec)</code></pre><p>where <code>spec</code> is a list of <span>$(k_1, \dots, k_N)$</span> tuples or vectors, or  <code>AbstractMatrix</code> where each column specifies such a tuple. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/ace/sparseprodpool.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.RRlmBasis" href="#Polynomials4ML.RRlmBasis"><code>Polynomials4ML.RRlmBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>real spherical harmonics:</p><p>Yₗ⁰ = P̄ₗ⁰/√2 Yₗᵐ =  Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Yₗ⁻ᵐ = -Im(P̄ₗᵐ(cosθ)/√2 exp(imφ))</p><p>solid harmonics:</p><p>Sₗ⁰ = √(4π/2l+1) rˡP̄ₗ⁰/√2 Sₗᵐ = (-1)ᵐ√(8π/2l+1) rˡ Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Sₗ⁻ᵐ = (-1)ᵐ√(8π/2l+1) rˡIm(P̄ₗᵐ(cosθ)/√2 exp(imφ))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rrlm.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.RTrigBasis" href="#Polynomials4ML.RTrigBasis"><code>Polynomials4ML.RTrigBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>RTrigBasis(N)</code>: </p><p>Real trigonometric polynomials up to degree <code>N</code> (inclusive). The basis is ordered as </p><pre><code class="nohighlight hljs">[1, cos(θ), sin(θ), cos(2θ), sin(2θ), ..., cos(Nθ), sin(Nθ) ]</code></pre><p>where <code>θ</code> is input variable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/rtrig.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.RYlmBasis" href="#Polynomials4ML.RYlmBasis"><code>Polynomials4ML.RYlmBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>RYlmBasis(maxL, T=Float64):</code></p><p>Real spherical harmonics; see tests to see how they are normalized, and  <code>idx2lm</code> on how they are ordered. The ordering is not guarenteed to be semver-stable.</p><p>The input variable is normally an <code>rr::SVector{3, T}</code>. This <code>rr</code> need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when <code>norm(rr) != 1</code>.</p><ul><li><code>maxL</code> : maximum degree of the spherical harmonics</li><li><code>T</code> : type used to store the coefficients for the associated legendre functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rylm.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SimpleProdBasis" href="#Polynomials4ML.SimpleProdBasis"><code>Polynomials4ML.SimpleProdBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Naive implementation of the product basis, intended only for testing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/ace/simpleprodbasis.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SparseProduct" href="#Polynomials4ML.SparseProduct"><code>Polynomials4ML.SparseProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SparseProduct</code> : a model layer to build tensor products</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sparseproduct.jl#L4-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SparseSymmProd" href="#Polynomials4ML.SparseSymmProd"><code>Polynomials4ML.SparseSymmProd</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SparseSymmProd</code> : sparse symmetric product with entries stored as tuples.  Input is a vector <code>A</code>; each entry of the output vector <code>AA</code> is of the form </p><p class="math-container">\[ {\bm A}_{i_1, \dots, i_N} = \prod_{t = 1}^N A_{i_t}.\]</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SparseSymmProd(spec)</code></pre><p>where <code>spec</code> is a list of tuples or vectors, each of which specifies an <code>AA</code> basis function as described above. For example, </p><pre><code class="language-julia hljs">spec = [ (1,), (2,), (1,1), (1,2), (2,2), 
         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]
basis = SparseSymmProd(spec)         </code></pre><p>defines a basis of 9 functions, </p><p class="math-container">\[[ A_1, A_2, A_1^2, A_1 A_2, A_2^2, A_1^3, A_1^2 A_2, A_1 A_2^2, A_2^3 ]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/ace/sparsesymmprod.jl#L9-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SparseSymmProdDAG" href="#Polynomials4ML.SparseSymmProdDAG"><code>Polynomials4ML.SparseSymmProdDAG</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct SparseSymmProdDAG</code> : alternative (recursive) implementation of  <code>SparseSymmProd</code>. This has better theoretical performance for high correlation  orders. </p><p>The potential downside is that it inserts auxiliary basis functions into the  basis. This means, that the specification of the output will be different  from the specification that is used to construct the basis. To that end, the  field <code>projection</code> can be used to reduce it back to the original spec. E.g., </p><pre><code class="language-julia hljs">basis = SparseSymmProd(spec)
basis_dag = SparseSymmProdDAG(spec)
A = randn(nA)
basis(A) ≈ basis_dag(A)[basis_dag.projection]   # true</code></pre><p>However, the field <code>projection</code> is used only for information, and not  to actually reduce the output. One could of course use it to compose  the output with a projection matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/ace/symmprod_dag.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SparseSymmProdDAG-Tuple{AbstractVector}" href="#Polynomials4ML.SparseSymmProdDAG-Tuple{AbstractVector}"><code>Polynomials4ML.SparseSymmProdDAG</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Construct the DAG used to evaluate an AA basis and returns it as a <code>SparseSymmProdDAG</code></p><p>Arguments</p><ul><li><code>spec</code> : AA basis specification, list of vectors of integers / indices pointing into A </li></ul><p>Kwargs: </p><ul><li><code>filter = _-&gt; true</code> : </li><li><code>verbose = false</code> : print some information about the </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/ace/symmprod_dag.jl#L144-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.SphericalCoords" href="#Polynomials4ML.SphericalCoords"><code>Polynomials4ML.SphericalCoords</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>struct SphericalCoords</code> : a simple datatype storing spherical coordinates of a point (x,y,z) in the format <code>(r, cosφ, sinφ, cosθ, sinθ)</code>. Use <code>spher2cart</code> and <code>cart2spher</code> to convert between cartesian and spherical coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/interface.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}" href="#Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}"><code>Polynomials4ML._init_luxparams</code></a> — <span class="docstring-category">Method</span></header><section><div><p>a fall-back method for <code>initalparameters</code> that all AbstractPoly4MLBasis should overload </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/lux.jl#L22-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, CRlmBasis}} where T" href="#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, CRlmBasis}} where T"><code>Polynomials4ML.cRlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/crlm.jl#L134-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, Polynomials4ML.SphericalCoords{T}, AbstractVector, CRlmBasis}} where T" href="#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, Polynomials4ML.SphericalCoords{T}, AbstractVector, CRlmBasis}} where T"><code>Polynomials4ML.cRlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/crlm.jl#L53-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CRlmBasis}} where T" href="#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CRlmBasis}} where T"><code>Polynomials4ML.cRlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/crlm.jl#L191-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, CRlmBasis}} where T" href="#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, CRlmBasis}} where T"><code>Polynomials4ML.cRlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/crlm.jl#L88-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cYlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, CYlmBasis}" href="#Polynomials4ML.cYlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, CYlmBasis}"><code>Polynomials4ML.cYlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/cylm.jl#L70-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cYlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, Any}} where T" href="#Polynomials4ML.cYlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, Any}} where T"><code>Polynomials4ML.cYlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/cylm.jl#L146-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, CYlmBasis}" href="#Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, CYlmBasis}"><code>Polynomials4ML.cYlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/cylm.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.cYlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CYlmBasis}} where T" href="#Polynomials4ML.cYlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CYlmBasis}} where T"><code>Polynomials4ML.cYlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of complex spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/cylm.jl#L202-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.chebyshev_basis-Tuple{Integer}" href="#Polynomials4ML.chebyshev_basis-Tuple{Integer}"><code>Polynomials4ML.chebyshev_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>chebyshev_basis(N::Integer)</code>: </p><p>Constructs an <code>OrthPolyBasis1D3T</code> object representing a possibly rescaled version of the basis of Chebyshev polynomials of the first kind. <code>N</code> is the length of the basis, not the degree. </p><p>Careful: the normalisation may be non-standard. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/jacobiweights.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.dspher_to_dcart-Tuple{Any, Any, Any}" href="#Polynomials4ML.dspher_to_dcart-Tuple{Any, Any, Any}"><code>Polynomials4ML.dspher_to_dcart</code></a> — <span class="docstring-category">Method</span></header><section><div><p>convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L27-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.idx2l-Tuple{Integer}" href="#Polynomials4ML.idx2l-Tuple{Integer}"><code>Polynomials4ML.idx2l</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Partial inverse of <code>lm2idx</code>: given an index into a vector of Ylm values, return the  <code>l</code> index. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L116-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.idx2lm-Tuple{Integer}" href="#Polynomials4ML.idx2lm-Tuple{Integer}"><code>Polynomials4ML.idx2lm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Inverse of <code>lm2idx</code>: given an index into a vector of Ylm values, return the  <code>l, m</code> indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L106-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.index_p-Tuple{Integer, Integer}" href="#Polynomials4ML.index_p-Tuple{Integer, Integer}"><code>Polynomials4ML.index_p</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>index_p(l,m):</code> Return the index into a flat array of Associated Legendre Polynomials <code>P_l^m</code> for the given indices <code>(l,m)</code>. <code>P_l^m</code> are stored in l-major order i.e. </p><pre><code class="nohighlight hljs">	[P(0,0), [P(1,0), P(1,1), P(2,0), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/alp.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.jacobi_basis-Tuple{Integer, Real, Real}" href="#Polynomials4ML.jacobi_basis-Tuple{Integer, Real, Real}"><code>Polynomials4ML.jacobi_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>jacobi_basis(N::Integer, α::Real, β::Real)</code>: </p><p>Constructs an <code>OrthPolyBasis1D3T</code> object representing a possibly rescaled version of the basis of Jacobi polynomials <code>Jαβ</code>. <code>N</code> is the length of the basis, not the degree. </p><p>Careful: the normalisation may be non-standard. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/jacobiweights.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.legendre_basis-Tuple{Integer}" href="#Polynomials4ML.legendre_basis-Tuple{Integer}"><code>Polynomials4ML.legendre_basis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>legendre_basis(N::Integer)</code>: </p><p>Constructs an <code>OrthPolyBasis1D3T</code> object representing a possibly rescaled version of the basis of Legendre polynomials (L2 orthonormal on [-1, 1]). <code>N</code> is the length of the basis, not the degree. </p><p>Careful: the normalisation may be non-standard. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/jacobiweights.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.lm2idx-Tuple{Integer, Integer}" href="#Polynomials4ML.lm2idx-Tuple{Integer, Integer}"><code>Polynomials4ML.lm2idx</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>lm2idx(l,m):</code> Return the index into a flat array of real spherical harmonics <code>Y_lm</code> for the given indices <code>(l,m)</code>. <code>Y_lm</code> are stored in l-major order i.e.</p><pre><code class="nohighlight hljs">	[Y(0,0), Y(1,-1), Y(1,0), Y(1,1), Y(2,-2), ...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.lux-Tuple{Polynomials4ML.AbstractPoly4MLBasis}" href="#Polynomials4ML.lux-Tuple{Polynomials4ML.AbstractPoly4MLBasis}"><code>Polynomials4ML.lux</code></a> — <span class="docstring-category">Method</span></header><section><div><p>lux(basis) : convert a basis / embedding object into a lux layer. This assumes  that the basis accepts a number or short vector as input and produces an output  that is a vector. It also assumes that batched operations are implemented,  as well as some other functionality. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/lux.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.maxL-Tuple{Union{CRlmBasis, CYlmBasis, RRlmBasis, RYlmBasis}}" href="#Polynomials4ML.maxL-Tuple{Union{CRlmBasis, CYlmBasis, RRlmBasis, RYlmBasis}}"><code>Polynomials4ML.maxL</code></a> — <span class="docstring-category">Method</span></header><section><div><p>max L degree for which the alp coefficients have been precomputed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.orthpolybasis-Union{Tuple{TW}, Tuple{Integer, Polynomials4ML.DiscreteWeights{TW}}} where TW" href="#Polynomials4ML.orthpolybasis-Union{Tuple{TW}, Tuple{Integer, Polynomials4ML.DiscreteWeights{TW}}} where TW"><code>Polynomials4ML.orthpolybasis</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>function orthpolybasis(...)</code> : construct a univariate orthogonal polynomial  basis with respect to some specified inner product. For the standard 3-term  recursion polynomials, use <code>legendre_basis</code>, <code>jacobi_basis</code> or <code>chebyshev_basis</code>. </p><p>The <code>orthpolybasis</code> currently implements orthogonal polynomials for discrete weights with the following constructors: </p><pre><code class="language-julia hljs">orthpolybasis(N::Integer, W::DiscreteWeights{TW}; TX = Float64)
orthpolybasis(N::Integer, X::AbstractVector{&lt;: Real}, 
              W::AbstractVector{&lt;: Real}, normalizeW=false; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/discreteweights.jl#L24-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.rRlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, RRlmBasis}" href="#Polynomials4ML.rRlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, RRlmBasis}"><code>Polynomials4ML.rRlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate real solid harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rrlm.jl#L57-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.rRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, RRlmBasis}} where T" href="#Polynomials4ML.rRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, RRlmBasis}} where T"><code>Polynomials4ML.rRlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of real spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rrlm.jl#L96-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.rYlm!-Tuple{Any, Any, Any, AbstractVector, RYlmBasis}" href="#Polynomials4ML.rYlm!-Tuple{Any, Any, Any, AbstractVector, RYlmBasis}"><code>Polynomials4ML.rYlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate real spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rylm.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.rYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, RYlmBasis}" href="#Polynomials4ML.rYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, RYlmBasis}"><code>Polynomials4ML.rYlm_ed!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>evaluate gradients of real spherical harmonics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/rylm.jl#L93-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.sizeP-Tuple{Any}" href="#Polynomials4ML.sizeP-Tuple{Any}"><code>Polynomials4ML.sizeP</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sizeP(maxL):</code>  Return the size of the set of Associated Legendre Polynomials <span>$P_l^m(x)$</span> of degree less than or equal to the given maximum degree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/alp.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials4ML.sizeY-Tuple{Any}" href="#Polynomials4ML.sizeY-Tuple{Any}"><code>Polynomials4ML.sizeY</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sizeY(maxL):</code> Return the size of the set of spherical harmonics <span>$Y_{l,m}(θ,φ)$</span> of degree less than or equal to the given maximum degree <code>maxL</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ACEsuit/Polynomials4ML.jl/blob/955f4f06c776e7a6554eefd7a6fb5ea83c453530/src/sphericalharmonics/sphericalharmonics.jl#L87-L91">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ace/">« Cluster Expansion</a><a class="docs-footer-nextpage" href="../experimental/">Experimental »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 21 July 2023 21:57">Friday 21 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
