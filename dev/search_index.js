var documenterSearchIndex = {"docs":
[{"location":"api/#In-place-Evaluation","page":"API","title":"In-place Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the in-place evaluation interface. All basis sets implemented in this package should provide this interface as a minimal requirement. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"evaluate!(P, basis, X)\nevaluate_ed!(P, dP, basis, X)\nevaluate_ed2!(P, dP, ddP, basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"basis : an object defining one of the basis sets \nX : a single input or array of inputs. \nP : array containing the basis values \ndP : array containing derivatives of basis w.r.t. inputs \nddP : array containing second derivatives of basis w.r.t. inputs ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then this should normally be a Number or a StaticArray to distinguish it from collections of inputs. X can also be an AbstractArray of admissible inputs, e.g., Vector{<: Number}. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then P, dP, ddP will be AbstractVector. If X is an AbstractVector of inputs then P, dP, ddP must be AbstractMatrix, and so forth. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The output arrays P, dP, ddP must be sufficiently large in each dimension to accomodate the size of the input and the size of the basis, but the sizes need not match exactly. It is up to the caller to ensure matching array sizes if this is needed.","category":"page"},{"location":"api/#Allocating-Evaluation","page":"API","title":"Allocating Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the allocating evaluation interface. All basis sets should implement this interface.","category":"page"},{"location":"api/","page":"API","title":"API","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\nP, dP, ddP = evaluate_ed2(basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The meaning of the different symbols is exactly the same as described above. The only difference is that the output arrays P, dP, ddP are now allocated and will have precise the correct shape to match the shape of the input. ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The interfaces specified below are experimental and not part of the public API. There is no guarantee of semver-compatible backward compatibility. ","category":"page"},{"location":"experimental/#Backward-Differentiation","page":"Experimental","title":"Backward Differentiation","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"[TODO]","category":"page"},{"location":"experimental/#Laplacian","page":"Experimental","title":"Laplacian","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The laplacian interface is experimental and should not be considered part of the public API. ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"For some applications it is important to have a fast evaluation of the laplace operator, which can often be achieved at far lower computational cost than a hessian. For example, spherical harmonics are eigenfunctions of the laplacian while solid harmonics have zero-laplacian. To exploit this we provide both in-place and allocating interfaces to evaluate the laplacians. In addition we provide an interface to evaluate the basis, its gradients as well as the laplacian, analogous to evaluate_ed2 above. This interface is convenient to evaluate laplacians of chains.","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"laplacian!(ΔY, basis, X)\nΔY = laplacian(basis, X)\neval_grad_laplace!(Y, dY, ΔY, basis, X)\nY, dY, ΔY = eval_grad_laplace(basis, X)","category":"page"},{"location":"experimental/#Lux","page":"Experimental","title":"Lux","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"[TODO]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Polynomials4ML","category":"page"},{"location":"#Polynomials4ML","page":"Home","title":"Polynomials4ML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Polynomials4ML.","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = Polynomials4ML","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [Polynomials4ML]","category":"page"},{"location":"docstrings/#Polynomials4ML.ALPolynomials","page":"Docstrings","title":"Polynomials4ML.ALPolynomials","text":"ALPolynomials : an auxiliary datastructure for evaluating the associated lagrange functions used for the spherical harmonics Constructor:\n\nALPolynomials(maxL::Integer, T::Type=Float64)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CTrigBasis","page":"Docstrings","title":"Polynomials4ML.CTrigBasis","text":"Complex trigonometric polynomials up to degree N (inclusive). The basis is  constructed in the order \n\n[1, exp(im*θ), exp(-im*θ), exp(2im*θ), exp(-2im*θ), ..., \n                                exp(N*im*θ), exp(-N*im*θ) ]\n\nwhere θ is input variable. These polynomials are orthonormal w.r.t. the  normalized L2-inner product on the torus. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CYlmBasis","page":"Docstrings","title":"Polynomials4ML.CYlmBasis","text":"complex spherical harmonics\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.MonoBasis","page":"Docstrings","title":"Polynomials4ML.MonoBasis","text":"Standard Monomials. This should very rarely be used.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.OrthPolyBasis1D3T","page":"Docstrings","title":"Polynomials4ML.OrthPolyBasis1D3T","text":"OrthPolyBasis1D3T: defined a basis of orthonormal polynomials on an interval  [a, b] in terms of the coefficients in the 3-term recursion, \n\nbeginaligned\n   P_1(x) = A_1  \n   P_2 = A_2 x + B_2 \n   P_n = (A_n x + B_n) P_n-1(x) + C_n P_n-2(x)\nendaligned\n\nOrthogonality is achieved with respect to a user-specified distribution, which can be either continuous or discrete but must have a density function.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SphericalCoords","page":"Docstrings","title":"Polynomials4ML.SphericalCoords","text":"struct SphericalCoords : a simple datatype storing spherical coordinates of a point (x,y,z) in the format (r, cosφ, sinφ, cosθ, sinθ). Use spher2cart and cart2spher to convert between cartesian and spherical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}","page":"Docstrings","title":"Polynomials4ML._init_luxparams","text":"a fall-back method for initalparameters that all AbstractPoly4MLBasis should overload \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm!-Tuple{Any, Any, AbstractVector{<:Polynomials4ML.SphericalCoords}, AbstractMatrix, Any}","page":"Docstrings","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector}","page":"Docstrings","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, AbstractVector{<:Polynomials4ML.SphericalCoords}, AbstractMatrix, AbstractMatrix, CYlmBasis}","page":"Docstrings","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any}","page":"Docstrings","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.dspher_to_dcart-Tuple{Any, Any, Any}","page":"Docstrings","title":"Polynomials4ML.dspher_to_dcart","text":"convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.idx2lm-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.idx2lm","text":"Inverse of index_y: given an index into a vector of Ylm values, return the  l, m indices.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.index_p-Tuple{Integer, Integer}","page":"Docstrings","title":"Polynomials4ML.index_p","text":"index_p(l,m): Return the index into a flat array of Associated Legendre Polynomials P_l^m for the given indices (l,m). P_l^m are stored in l-major order i.e. \n\n\t[P(0,0), [P(1,0), P(1,1), P(2,0), ...]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.index_y-Tuple{Integer, Integer}","page":"Docstrings","title":"Polynomials4ML.index_y","text":"index_y(l,m): Return the index into a flat array of real spherical harmonics Y_lm for the given indices (l,m). Y_lm are stored in l-major order i.e.\n\n\t[Y(0,0), Y(1,-1), Y(1,0), Y(1,1), Y(2,-2), ...]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.lux-Tuple{Polynomials4ML.AbstractPoly4MLBasis}","page":"Docstrings","title":"Polynomials4ML.lux","text":"lux(basis) : convert a basis / embedding object into a lux layer. This assumes  that the basis accepts a number or short vector as input and produces an output  that is a vector. It also assumes that batched operations are implemented,  as well as some other functionality. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.maxL-Tuple{CYlmBasis}","page":"Docstrings","title":"Polynomials4ML.maxL","text":"max L degree for which the alp coefficients have been precomputed\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rYlm!-Tuple{Any, Any, Any, AbstractVector}","page":"Docstrings","title":"Polynomials4ML.rYlm!","text":"evaluate real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rYlm_ed!-NTuple{6, Any}","page":"Docstrings","title":"Polynomials4ML.rYlm_ed!","text":"evaluate gradients of real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.sizeP-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.sizeP","text":"sizeP(maxL):  Return the size of the set of Associated Legendre Polynomials P_l^m(x) of degree less than or equal to the given maximum degree\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.sizeY-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.sizeY","text":"sizeY(maxL): Return the size of the set of spherical harmonics Y_lm(θφ) of degree less than or equal to the given maximum degree maxL\n\n\n\n\n\n","category":"method"}]
}
