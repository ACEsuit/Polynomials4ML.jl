var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This page documents the public API, i.e. the list of bases and functions that are considered relatively stable and for which we aim to strictly impose semver backward compatibility. The basis sets that are considered stable are the following (please see inline documentation for initialization): ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Several classes of orthogonal polynomials OrthPolyBasis1D3T\nGeneral Jacobi jacobi_basis\nLegendre legendre_basis\nChebyshev chebyshev_basis\nDiscrete distribution orthpolybasis \n2D harmonics: \nComplex trigonometric polynomials CTrigBasis\nReal trigonometric polynomials RTrigBasis\n3D harmonics: \nComplex spherical harmonics CYlmBasis\nReal spherical harmonics RYlmBasis\nComplex solid harmonics CRlmBasis\nReal solid harmonics RRlmBasis\nChebyshev polynomials of the first kind ChebBasis\nCluster Expansion: \nFused tensor produce and pooling PooledSparseProduct\nSparse symmetric product SparseSymmProd\nAlternative sparse symmetric product implementation SparseSymmProdDAG \nLinearLayer LinearLayer\nVarious quantum chemistry related radial basis functions. (experimental)","category":"page"},{"location":"api/#In-place-Evaluation","page":"API","title":"In-place Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the in-place evaluation interface. The polynomial basis sets implemented in this package should provide this interface as a minimal requirement. The cluster expansion features do not implement these at present. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"evaluate!(P, basis, X)\nevaluate_ed!(P, dP, basis, X)\nevaluate_ed2!(P, dP, ddP, basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"basis : an object defining one of the basis sets \nX : a single input or array of inputs. \nP : array containing the basis values \ndP : array containing derivatives of basis w.r.t. inputs \nddP : array containing second derivatives of basis w.r.t. inputs ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then this should normally be a Number or a StaticArray to distinguish it from collections of inputs. X can also be an AbstractArray of admissible inputs, e.g., Vector{<: Number}. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then P, dP, ddP will be AbstractVector. If X is an AbstractVector of inputs then P, dP, ddP must be AbstractMatrix, and so forth. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The output arrays P, dP, ddP must be sufficiently large in each dimension to accomodate the size of the input and the size of the basis, but the sizes need not match exactly. It is up to the caller to ensure matching array sizes if this is needed.","category":"page"},{"location":"api/#Allocating-Evaluation","page":"API","title":"Allocating Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the allocating evaluation interface. All basis sets should implement this interface.","category":"page"},{"location":"api/","page":"API","title":"API","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\nP, dP, ddP = evaluate_ed2(basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The output types of P, dP, ddP are guaranteed to be AbstractArrays but may otherwise change between package versions. The exact type should not be relied upon when using this package.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The meaning of the different symbols is exactly the same as described above. The only difference is that the output containers P, dP, ddP are now allocated.  Their type should be stable (if not, please file a bug report), but unspecified in the sense that the output type is not semver-stable for the time being.  If you need a sem-ver stable output then it is best to follow the above with a collect.","category":"page"},{"location":"api/#Re-using-Output-Arrays","page":"API","title":"Re-using Output Arrays","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"For many models / bases, pullbacks, etc, the default output arrays are of type CachedArray.  This means that after they have been used, they can be released back into an array cache from which they have been acquired. (See ObjectPools.jl for more details.) This will avoid a new allocation next time a basis is evaluated. The interface for this is ","category":"page"},{"location":"api/","page":"API","title":"API","text":"B = evaluate(basis, X)\nrelease!(B)\nB, dB = evaluate_ed(basis, X)\nrelease!(B)\nrelease!(dB)\n# ... and so forth ... ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The release! function can still be applied to output arrays that are not a CachedArray, this will then simply be a no-op. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"danger: Usage of `CachedArray` outputs\nCachedArrays can cause type instabilities when used in unexpected ways. To prevent this, if B::CachedArray is an output from a basis (or similar) simply use its unwrapped PtrArray instead by calling unwrap(B) in ObjectPools.jl. This will extract the internally stored array, normally a core Julia Array or a PtrArray from the package StrideArrays.jl. ","category":"page"},{"location":"api/#ChainRules.jl-integration","page":"API","title":"ChainRules.jl integration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"We aim to provide ChainRules.jl integration for all model components. At present, we have focused on providing the rrule interface. If basis is a polynomial basis (or other model component) then one can obtain its value and pullback via the ChainRules.jl interface, ","category":"page"},{"location":"api/","page":"API","title":"API","text":"B, pb = rrule(evaluate, basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"Internally, the pullback pb will most likely call a custom implementation of the pullback operation. Where possible we also implement pullbacks over pullbacks to enable second-order backward differentiation. This is needed when minimizing a loss function that involves a model derivative.","category":"page"},{"location":"api/","page":"API","title":"API","text":"If any rrules are missing or not working as expected, please file an issue. ","category":"page"},{"location":"api/#Lux.jl-Integration","page":"API","title":"Lux.jl Integration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Although all bases and models components that we implement here can be used \"as is\", we also aim to provide wrappers that turn them into Lux.jl layers. For any basis or model component basis, one can simply call ","category":"page"},{"location":"api/","page":"API","title":"API","text":"l_basis = lux(basis)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The resulting object l_basis can then be used to construct networks using the Lux.jl package. ","category":"page"},{"location":"experimental/#Experimental-API","page":"Experimental","title":"Experimental API","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The interfaces specified below are experimental and not part of the public API yet. Some of it is not even implemented yet and are just being sketched out in separate branches. There is no guarantee that these are provided for all of the exported basis sets, and there is no guarantee of semver-compatible backward compatibility at this point.","category":"page"},{"location":"experimental/#Some-General-Experimental-/-Undocumented-Objects","page":"Experimental","title":"Some General Experimental / Undocumented Objects","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"SparseProduct : a model layer to form tensor products of features, e.g., tensor product polynomial bases. ","category":"page"},{"location":"experimental/#Laplacian","page":"Experimental","title":"Laplacian","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The laplacian interface is experimental and should not be considered part of the public API. ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"For some applications it is important to have a fast evaluation of the laplace operator, which can often be achieved at far lower computational cost than a hessian. For example, spherical harmonics are eigenfunctions of the laplacian while solid harmonics have zero-laplacian. To exploit this we provide both in-place and allocating interfaces to evaluate the laplacians. In addition we provide an interface to evaluate the basis, its gradients as well as the laplacian, analogous to evaluate_ed2 above. This interface is convenient to evaluate laplacians of chains.","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"laplacian!(ΔY, basis, X)\nΔY = laplacian(basis, X)\neval_grad_laplace!(Y, dY, ΔY, basis, X)\nY, dY, ΔY = eval_grad_laplace(basis, X)","category":"page"},{"location":"experimental/#Explicit-Backward-Differentiation","page":"Experimental","title":"Explicit Backward Differentiation","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"We implement custom pullbacks for most bases. These  take the form","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"∂X = pb_evaluate(basis, ∂B, X, args...)\npb_evaluate!(∂X, basis, ∂B, X, args...)","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"and analogously for the evaluate_*** variants. The args... can differ between different basis sets e.g. may rely on intermediate results in the evaluation of the basis. The rrule implementations are wrappers for these.","category":"page"},{"location":"tutorials/#Tutorials-Index","page":"Tutorial Index","title":"Tutorials Index","text":"","category":"section"},{"location":"tutorials/","page":"Tutorial Index","title":"Tutorial Index","text":"This is a preliminary list of tutorials for the P4ML package, generated using Literate.jl. The literate source can be found in Polynomials4ML.jl/tutorials/.","category":"page"},{"location":"tutorials/","page":"Tutorial Index","title":"Tutorial Index","text":"Polynomial Regression","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"EditURL = \"../../../tutorials/polyregression.jl\"","category":"page"},{"location":"literate_tutorials/polyregression/#Linear-Polynomial-Regression","page":"Linear Regression","title":"Linear Polynomial Regression","text":"","category":"section"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"This tutorial show how to use the P4ML package to perform a naive polynomial regression. This is not really the intended use-case of the package, but it serves to illustrate some basic usage and functionality.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"using Polynomials4ML, LinearAlgebra, StaticArrays","category":"page"},{"location":"literate_tutorials/polyregression/#Example-1:-Univariate-Polynomial-Regression","page":"Linear Regression","title":"Example 1: Univariate Polynomial Regression","text":"","category":"section"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"First, we specify a target function, which we will try to approximate.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"f1(x) = 1 / (1 + 10 * x^2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"Suppose we are given data in the form of argument, function value pairs, with arguments sampled uniformly from the interval [-1, 1].","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"N = 1_000\nXtrain = 2 * rand(N) .- 1\nYtrain = f1.(Xtrain);\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"We want to solve the least squares problem","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"  min_p sum_i = 1^N  y_i - p(x_i) ^2","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"for a polynomial p. Because f_1 is analytic, we use a degree approximately sqrtN. Since the distribution of the samples is uniform, the Legrendre polynomials are likely a good choice.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"basis = legendre_basis(ceil(Int, sqrt(N)))\nc = basis(Xtrain) \\ Ytrain\np = x -> sum(c .* basis(x));\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"A quick statistical test error","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"Xtest = 2 * rand(N) .- 1\nYtest = f1.(Xtest)\nprintln(\"Test RMSE: \", norm(Ytest - p.(Xtest)) / sqrt(N))","category":"page"},{"location":"literate_tutorials/polyregression/#Example-2:-Polynomial-Regression-on-the-Sphere","page":"Linear Regression","title":"Example 2: Polynomial Regression on the Sphere","text":"","category":"section"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"As a second example we consider a function defined on the unit sphere,","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"f2(x) = 1 / (1 + 10 * norm(x - SA[1.0,0.0,0.0])^2);\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"where x is now an SVector{3, Float64} with norm(x) == 1. We generate again uniform samples on the sphere.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"N = 1_000\nX = [ (x = randn(SVector{3, Float64}); x/norm(x)) for i = 1:N ]\nY = f2.(X);\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"In this case, spherical harmonics are natural basis functions. P4ML implements both real and complex spherical harmonics. Since the target function is real, we choose the real basis.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"basis = RYlmBasis(9)\n@show length(basis);\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"We see that we now have far more basis functions per degree and therefore cannot use as high a degree as before (unless we give ourselves more data). Otherwise we can proceed exactly as above.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"c = basis(X) \\ Y\np = x -> sum(c .* basis(x));\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"We can test the RMSE again.","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"Xtest = [ (x = randn(SVector{3, Float64}); x/norm(x)) for i = 1:N ]\nYtest = f2.(Xtest)\nprintln(\"Test RMSE: \", norm(Ytest - p.(Xtest)) / sqrt(N));\nnothing #hide","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"","category":"page"},{"location":"literate_tutorials/polyregression/","page":"Linear Regression","title":"Linear Regression","text":"This page was generated using Literate.jl.","category":"page"},{"location":"ace/#Cluster-Expansion","page":"Cluster Expansion","title":"Cluster Expansion","text":"","category":"section"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"The Atomic Cluster Expansion (ACE) and its relatives and derivatives are one of the main reasons we wrote P4ML.  ACE can be thought of as a highly efficient but systematic scheme to construct polynomial approximations of permutation invariant functions or of multi-set functions, that may in addition be equivariant under some Lie group action. The same model components can also be used to construct euquivariant message passing networks such as E3NN. ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"Here, we focus only on the permutation invariance. This brief introduction documents ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"PooledSparseProduct\nSparseSymmProd\nSparseSymmProdDAG ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"This document only provides background. For usage, we refer to the inline documention. ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"Suppose we have such a multi-set function","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"    f( x_j_j )","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"where x_j_j denotes a multi-set and each set element x_j in mathbbR^d is a vector (though it could also be a more general object). In the cluster expansion, one starts with an embedding of x_j into an abstract space V given by a one-particle basis phi_k, i.e., ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"    x_j mapsto (phi_k(x_j))_k in V","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"The polynomial bases implemented in P4ML (orthogonal polynomials, trigonometric polynomials, spherical harmonics, etc) can be used to construct those one-particle embeddings. Here, we keep phi_k V abstract so that we can focus on the two key model components that are unique to ACE. ","category":"page"},{"location":"ace/#Fused-Product-and-Pooling","page":"Cluster Expansion","title":"Fused Product and Pooling","text":"","category":"section"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"Given a one-particle embedding, we obtain an embedding of the multiset x_j_j into the same space V, ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"   A = (A_k)_k quad textwhere quad \n   A_k( x_j_j ) = sum_j phi_k(x_j)","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"This is implemented using a fused sparse product and pooling operation:","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"PooledSparseProduct","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"This is a model layer that merged the pooling operation sum_j with taking the product that is normally involved when evaluating phi_k. When x_j are a vector, then phi_k(x_j) is normally a tensor product, e.g., phi_nlm(bm r) = R_nl(r) Y_l^m(hatbm r). ","category":"page"},{"location":"ace/#N-Correlations-(Symmetric-Product)","page":"Cluster Expansion","title":"N-Correlations (Symmetric Product)","text":"","category":"section"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"After forming the embedding A the cluster expansion models then for symmetric tensor products, or, N-correlations, ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"   bm A_k_1 dots k_N = prod_t = 1^N A_k_t","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"This can also be seen as a symmetric rank-1 product A otimes cdots otimes A. ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"If the phi_k form a complete basis of one-particle functions, then the bm A_bm k form a complete basis of multi-set functions. E.g., one can then expand a permutation-invariant function as ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"   f(x_j_j) = sum_bm k in mathcalK c_bm k bm A_bm k(x_j_j)","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"where mathcalK is a list of ordered (k_t) tuples specifying the basis. ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"There are two different implementations of this model component in P4ML: ","category":"page"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"SparseSymmProd : a naive implementation that is performant for relatively small N\nSparseSymmProdDAG : a more efficient recursive implementation, behaves slightly differently, to be used with care","category":"page"},{"location":"ace/#References","page":"Cluster Expansion","title":"References","text":"","category":"section"},{"location":"ace/","page":"Cluster Expansion","title":"Cluster Expansion","text":"Ralf Drautz. Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter, 99(1):014104, January 2019\nDusson, G., Bachmayr, M., Csányi, G., Drautz, R., Etter, S., van der Oord, C., & Ortner, C. (2022). Atomic cluster expansion: Completeness, efficiency and stability. Journal of Computational Physics, 454, 110946.\nYury Lysogorskiy, Cas van der Oord, Anton Bochkarev, Sarath Menon, Matteo Rinaldi, Thomas Hammerschmidt, Matous Mrovec, Aidan Thompson, G ́abor Cs ́anyi, Christoph Ortner, and Ralf Drautz. Performant implementation of the atomic cluster expansion (pace) and application to copper and silicon. npj Computational Materials, 7(1):97, 2021.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Polynomials4ML","category":"page"},{"location":"#Polynomials4ML.jl","page":"Home","title":"Polynomials4ML.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Polynomials4ML.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\", \"tutorials.md\", \"SH.md\", \"ace.md\", \"docstrings.md\", \"experimental.md\", ]\nDepth = 2","category":"page"},{"location":"SH/#Spherical-Harmonics","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"This section provides documentation for the evaluation of complex and real spherical harmonics and solid harmonics, including gradient and Laplacian calculations. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Associated Legendre Polynomials\nComplex Spherical Harmonics\nComplex Solid Harmonics\nReal Spherical Harmonics\nReal Solid Harmonics","category":"page"},{"location":"SH/#Associated-Legendre-Polynomials","page":"Spherical Harmonics","title":"Associated Legendre Polynomials","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Associated Legendre polynomials P_ell^m are closely related to the spherical harmonics, P_ell^m of degree ell and order mgeq 0 are defined as (in the phase convention of Condon and Shortley)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"\tP_ell^m(x) = frac(-1)^m2^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The negative order can be related to the corresponding positive order via a proportionality constant that involves only ell and m, ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P_ell^-m(x) = (-1)^m frac(ell-m)(ell+m)P_ell^m(x) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The associated Legendre polynomials are orthogonal on the interval -1leq xleq 1 in the sense that ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"int_-1^1 P_k^m(x) P_ell^m(x) mathrmdx = frac22ell+1frac(ell+m)(ell-m)delta_kell ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In alp.jl, Polynomials4ML utilizes the following normalization for the associated Legendre polynomials,  ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"barP_ell^m(x) = sqrtfrac(2ell+1)(ell-m)2pi (ell+m)P_ell^m qquad mgeq 0","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"and one can generate a data structure as ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"ALPs = ALPolynomials(maxL::Integer, T::Type=Float64)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"where maxL specifies the maximum degree of the polynomials. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The associated Legendre polynomials allow for ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"X is a point in spherical coordinates, P and dp stores P_l^m(X.cosθ) and dP_l^m(X.cosθ). Specifically, only non-negative m terms are stored, and are arranged in ell-major order. To retrieve the specific values of P_l^m and dP_l^m for given indices (l, m), one can use","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"index_p(l,m)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The algorithm for computing associated Legendre polynomials is based on Dusson(2022) eq.(A.7), where A_l^m, B_l^m, C_l^m can be found in Limpanuparb(2014) eq.(7)-(14). ","category":"page"},{"location":"SH/#Condon-Shortley-Sign-Convention","page":"Spherical Harmonics","title":"Condon-Shortley Sign Convention","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"There are two sign conventions for associated Legendre polynomials. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P_ell^m(x) = frac(-1)^m2^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P_ell^m(x) = frac12^ellell(1-x^2)^m2fracmathrmd^ell+mmathrmdx^ell+m(x^2-1)^ell","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"One possible way to distinguish the two conventions is","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P_ell m(x) = (-1)^m P_ell^m(x) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The Condon-Shortley sign convention enables us to establish the following relationships between spherical harmonics and angular momentum ladder operators","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Y_ell^m(theta varphi) = A_ell mhatL_-^ell-mY_ell^ell(theta varphi) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Y_ell^m(theta varphi) = A_ell -mhatL_+^ell+mY_ell^-ell(theta varphi) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"with all positive constants A_ell m = sqrtfrac(ell+m)(2ell)(ell+m). Ignoring the Condon-Shortley phase would introduce signs into the A_ell m. It's only a sign convention. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Including the factor of (-1)^m and written in terms x=costheta,  the first few associated Legendre polynomials are ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"mbackslashell 0 1 2 3\n3    -15sin^3theta\n2   3sin^2theta 15costhetasin^2theta\n1  -sintheta -3sinthetacostheta -frac32(5cos^2theta - 1)sintheta\n0 1 costheta frac12(3cos^2theta - 1) frac12costheta(5cos^2theta-3)","category":"page"},{"location":"SH/#Complex-Spherical-Harmonics","page":"Spherical Harmonics","title":"Complex Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In cylm.jl, Polynomials4ML utilizes orthonormalized complex spherical harmonics that includes the Condon-Shortley phase, defined as","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"\tY_ell^m(theta varphi) = sqrtfrac2ell+14pifrac(ell-m)(ell+m)P_ell^m(cos theta)mathrme^mathrmim varphi ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The normalization in complex spherical harmonics is chosen to satisfy","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"\tint_0^2piint_0^piY_k^m(theta varphi)barY_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi =delta_kelldelta_mn","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Orthonormalized complex spherical harmonics that include the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"mbackslashell 0 1 2 3\n3    -frac18sqrtfrac35picdot mathrme^3mathrmivarphicdot sin^3theta\n2   frac14sqrtfrac152picdot mathrme^2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^2mathrmivarphicdot sin^2thetacdot costheta\n1  -frac12sqrtfrac32picdot mathrme^mathrmivarphicdot sintheta -frac12sqrtfrac152picdot mathrme^mathrmivarphicdot sintheta cdot costheta -frac18sqrtfrac21picdot mathrme^mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n0 frac12sqrtfrac1pi frac12sqrtfrac3picdot cos theta frac14sqrtfrac5picdot (3cos^2theta - 1) frac14sqrtfrac7picdot (5cos^3theta - 3costheta)\n-1  frac12sqrtfrac32picdot mathrme^-mathrmivarphicdot sintheta frac12sqrtfrac152picdot mathrme^-mathrmivarphicdot sintheta cdot costheta frac18sqrtfrac21picdot mathrme^-mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n-2   frac14sqrtfrac152picdot mathrme^-2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^-2mathrmivarphicdot sin^2thetacdot costheta\n-3    frac18sqrtfrac35picdot mathrme^-3mathrmivarphicdot sin^3theta","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"To generate the complex spherical harmonics Y_ell^m with normalized associated Legendre polynomials barP_ell^m, the formulas can be rewritten as","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"begincases\nY_ell^0(theta varphi) = sqrtfrac12barP_ell^0(cos theta)\nY_ell^m(theta varphi) = sqrtfrac12barP_ell^m(cos theta)mathrme^mathrmim varphi\nY_ell^-m(theta varphi) = (-1)^mcdot sqrtfrac12 barP_ell^m(cos theta)mathrme^-mathrmim varphi\nendcases qquad m0","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"To evaluate the gradients of the spherical harmonics nabla Y_ell^m, one need to convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates, ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"begincases\n(fracpartial varphipartial x fracpartial varphipartial y fracpartial varphipartial z) = (-fracsinvarphirsin theta fraccosvarphirsin theta 0)\n(fracpartial thetapartial x fracpartial thetapartial y fracpartial thetapartial z) = (fraccos varphi cos thetar fracsin varphi cos thetar -fracsin thetar)\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Therefore, the gradient of Y_ell^m can be expressed as,","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"nabla Y_ell^m = fracmathrmim P_ell^m mathrme^mathrmimvarphirsin thetabeginbmatrix -sin varphi cos varphi 0 endbmatrix + \nfracpartial_thetaP_ell^m mathrme^mathrmimvarphirbeginbmatrix cos varphi cos thetasin varphicos theta -sintheta endbmatrix","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"For the sake of simplicity, we incorporated the coefficient in of P_ell^m into the term P_ell^m itself.","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"To ensure numerically stable evaluation of gradients near sin theta = 0, we compute P_ell^msin theta instead of P_ell^m. We refer to section A.1 of Dusson(2022) for detailed discussion.","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"We can further compute nabla^2 Y_ell^m as, ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"nabla^2 Y_ell m = left(frac1r^2fracpartialpartial r r^2fracpartialpartial r - fracL^2r^2    right)Y_ell^m = -fracell(ell+1)r^2Y_ell^m","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"One can generate a data structure as ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"cylm = CYlmBasis(maxL::Integer, T::Type=Float64)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The complex spherical harmonics allow for ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"To retrieve the specific values of Y_l^m and dY_l^m for given indices (l, m), one can use","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"index_y(l,m)","category":"page"},{"location":"SH/#Alternative-normalizations-conventions","page":"Spherical Harmonics","title":"Alternative normalizations conventions","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Here, we provide a list of alternative normalizations conventions for complex spherical harmonics,","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Schmidt semi-normalized (Racah's normalization)","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"C_ell^m(theta varphi) = sqrtfrac4pi2ell + 1Y_ell^m(theta varphi) = sqrtfrac(ell-m)(ell+m)P_ell^m(cos theta)mathrme^mathrmim varphi ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"with ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"int_0^2piint_0^piC_k^m(theta varphi)barC_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi = frac4pi2ell + 1delta_kelldelta_mn ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In this normalization, C_0^0(theta varphi) is equal to 1. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"4π-normalized","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"mathscrY_ell^m (theta varphi) = sqrt4piY_ell^m(theta varphi) = sqrt(2ell+1)frac(l-m)(l+m)P_ell^m(cos theta)mathrme^mathrmim varphi ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"with ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"int_0^2piint_0^pimathscrY_k^m(theta varphi)barmathscrY_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi = 4pidelta_kelldelta_mn ","category":"page"},{"location":"SH/#Complex-Solid-Harmonics","page":"Spherical Harmonics","title":"Complex Solid Harmonics","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In crlm.jl, Polynomials4ML utilizes orthonormalized complex solid harmonics defined as","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"\tgamma_ell^m(r theta varphi) = r^ellY_ell^m(theta varphi) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"gamma_ell^m's are orthogonal is the sense that ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"\tint_0^2piint_0^pigamma_k^m(theta varphi)bargamma_ell^n(theta varphi)sin theta mathrmdthetamathrmdvarphi =delta_kelldelta_mnr^k+ell","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"The evaluation of solid harmonics can be obtained from the spherical harmonics by a simple scaling with r^ell.  To evaluate the gradients of the solid harmonics, nabla gamma_ell^m, the following expressions are used,","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"begincases\n(fracpartial rpartial x fracpartial rpartial y fracpartial rpartial z) = (sin theta cos varphisinthetasin varphi cos theta)\n(fracpartial varphipartial x fracpartial varphipartial y fracpartial varphipartial z) = (-fracsinvarphirsin theta fraccosvarphirsin theta 0)\n(fracpartial thetapartial x fracpartial thetapartial y fracpartial thetapartial z) = (fraccos varphi cos thetar fracsin varphi cos thetar -fracsin thetar)\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Therefore, the gradient of gamma_ell^m can be expressed as,","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"nabla gamma_ell^m = fracell r^ell P_ell^m mathrme^mathrmimvarphirbeginbmatrix sin theta cos varphi sinthetasin varphi cos theta endbmatrix+ fracmathrmim P_ell^m mathrme^mathrmimvarphirsin thetabeginbmatrix -sin varphi cos varphi 0 endbmatrix + \nfracpartial_thetaP_ell^m mathrme^mathrmimvarphirbeginbmatrix cos varphi cos thetasin varphicos theta -sintheta endbmatrix","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Similarly, we incorporated the coefficient in of P_ell^m into the term P_ell^m itself. We can further compute nabla^2 gamma_ell^m as, ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"nabla^2 r^ellY_ell m = left(frac1r^2fracpartialpartial r r^2fracpartialpartial r - fracL^2r^2    right)r^ellY_ell^m = fracY_ell mr^2fracpartialpartial rr^2fracpartial r^ellpartial r - fracr^ellL^2 Y_ell^mr^2 = 0","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"that is, the solid harmonics are solutions to Laplace's equation. ","category":"page"},{"location":"SH/#Real-Spherical-Harmonics","page":"Spherical Harmonics","title":"Real Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In rylm.jl, Polynomials4ML utilizes orthonormalized real spherical harmonics that exclude the Condon-Shortley phase. ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Y_ell m(theta varphi)  = \nbegincases\nfracmathrmisqrt2(Y_ell^m - (-1)^m Y_ell^-m)  m  0\nY_ell^0  m = 0 \nfrac1sqrt2(Y_ell^-m + (-1)^m Y_ell^m)  m  0\nendcases = \nbegincases\n(-1)^m barP_ell^m(cos theta)sin(mvarphi)  m  0\nfrac1sqrt2 barP_ell^0(cos theta)  m = 0 \n(-1)^m barP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Y_ell m(theta varphi) = \nbegincases\n-barP_ell^m(cos theta)sin(mvarphi)  m  0\nfrac1sqrt2 barP_ell^0(cos theta)  m = 0 \nbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Orthonormalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"mbackslashell 0 1 2 3\n3    frac14sqrtfrac352picdot fracx(x^2-3y^2)r^3\n2   frac14sqrtfrac15picdot fracx^2-y^2r^2 frac14sqrtfrac105picdot frac(x^2-y^2)zr^3\n1  sqrtfrac34picdot fracxr frac12sqrtfrac15picdot fraczxr^2 frac14sqrtfrac212picdot fracx(5z^2-r^2)r^3\n0 frac12sqrtfrac1pi sqrtfrac34picdot fraczr frac14sqrtfrac5picdot frac3z^2-r^2r^2 frac14sqrtfrac7picdot fracz(5z^2-3r^2)r^3\n-1  sqrtfrac34picdot fracyr frac12sqrtfrac15picdot fracyzr^2 frac14sqrtfrac212picdot fracy(5z^2-r^2)r^3\n-2   frac12sqrtfrac15picdot fracxyr^2 frac12sqrtfrac105picdot fracxyzr^2\n-3    frac14sqrtfrac352picdot frac(3x^2-y^2)yr^3","category":"page"},{"location":"SH/#Real-Solid-Harmonics","page":"Spherical Harmonics","title":"Real Solid Harmonics","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"In rrlm.jl, Polynomials4ML utilizes Schmidt semi-normalized real solid harmonics that exclude the Condon-Shortley phase.","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"S_ell m(r theta varphi)  = \nbegincases\nfracmathbbisqrt2left(C_ell m-(-1)^m C_ell-m right)  m  0\nC_10  m = 0 \n frac1sqrt2left(C_ell -m+(-1)^m C_ellmright)   m  0\nendcases = begincases\n(-1)^m sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)sin(mvarphi)  m  0\nsqrtfrac2pi2l+1barP_ell^0(cos theta)  m = 0 \n(-1)^m sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"where ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"C_ell m(r theta varphi) = sqrtfrac4pi2ell + 1gamma_ell^m(theta varphi) ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"with ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"int_0^2piint_0^piC_km(r theta varphi)barC_ell n(r theta varphi)sin theta mathrmdthetamathrmdvarphi = frac4pi2ell + 1delta_kelldelta_mn r^k+ell ","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"S_ell m(r theta varphi)  = \nbegincases\n-sqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)sin(mvarphi)  m  0\nsqrtfrac2pi2l+1barP_ell^0(cos theta)  m = 0 \nsqrtfrac4pi2l+1cdot r^ellbarP_ell^m(cos theta)cos(mvarphi)   m  0\nendcases","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Schmidt semi-normalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"mbackslashell 0 1 2 3\n3    frac12sqrtfrac52(x^2-3y^2)x\n2   frac12sqrt3(x^2-y^2) frac12sqrt15(x^2-y^2)z\n1  x sqrt3xz frac12sqrtfrac32(5z^2-r^2)x\n0 1 z frac12(3z^2-r^2) frac12(5z^2-3r^2)z\n-1  y sqrt3yz frac12sqrtfrac32(5z^2-r^2)y\n-2   sqrt3xy sqrt15xyz\n-3    frac12sqrtfrac52(3x^2-y^2)y","category":"page"},{"location":"SH/#References","page":"Spherical Harmonics","title":"References","text":"","category":"section"},{"location":"SH/","page":"Spherical Harmonics","title":"Spherical Harmonics","text":"Dusson, G., Bachmayr, M., Csányi, G., Drautz, R., Etter, S., van der Oord, C., & Ortner, C. (2022). Atomic cluster expansion: Completeness, efficiency and stability. Journal of Computational Physics, 454, 110946.\nHelgaker, T., Jorgensen, P., & Olsen, J. (2013). Molecular electronic-structure theory. John Wiley & Sons.\nLimpanuparb, T., & Milthorpe, J. (2014). Associated Legendre polynomials and spherical harmonics computation for chemistry applications. arXiv preprint arXiv:1410.1748.  \nWieczorek, M. A., & Meschede, M. (2018). SHTools: Tools for working with spherical harmonics. Geochemistry, Geophysics, Geosystems, 19(8), 2574-2592.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = Polynomials4ML\nDocTestSetup = quote\n    using Polynomials4ML\nend","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"This page lists all docstrings in Polynomials4ML including for functions that are not part of the public API. Please check with the Public API which functionality for which we aim to guarantee semver-stability.","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [Polynomials4ML,Polynomials4ML.Utils]","category":"page"},{"location":"docstrings/#Polynomials4ML.ALPolynomials","page":"Docstrings","title":"Polynomials4ML.ALPolynomials","text":"ALPolynomials : an auxiliary datastructure for evaluating the associated Legendre functions used for the spherical and solid harmonics. Constructor:\n\nALPolynomials(maxL::Integer, T::Type=Float64)\n\nThis is not part of the public API and not guaranteed to be semver-stable. Only the resulting harmonics that use the ALPs are guaranteed to be backward  compatible. \n\nImportant Note: evaluate_ed!` does NOT return derivatives, but rather  produces rescaled derivatives for better numerical stability near the poles.  See comments in code for details on how to use the ALP derivatives correctly. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CRlmBasis","page":"Docstrings","title":"Polynomials4ML.CRlmBasis","text":"complex spherical harmonics: \n\nYₗ⁰(θ, φ) = P̄ₗ⁰(cosθ)/√2 Yₗᵐ(θ, φ) = P̄ₗᵐ(cosθ)exp(imφ)/√2 Yₗ⁻ᵐ(θ, φ) = (-1)ᵐ P̄ₗᵐ(cosθ)/√2 exp(-imφ)\n\nsolid harmonics:\n\nγₗᵐ(r, θ, φ) = rˡYₗᵐ(θ, φ)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CTrigBasis","page":"Docstrings","title":"Polynomials4ML.CTrigBasis","text":"Complex trigonometric polynomials up to degree N (inclusive). The basis is  constructed in the order \n\n[1, exp(im*θ), exp(-im*θ), exp(2im*θ), exp(-2im*θ), ..., \n                                exp(N*im*θ), exp(-N*im*θ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.CYlmBasis","page":"Docstrings","title":"Polynomials4ML.CYlmBasis","text":"CYlmBasis(maxL, T=Float64):\n\nComplex spherical harmonics; see tests to see how they are normalized, and  idx2lm on how they are ordered. The ordering is not guarenteed to be semver-stable.\n\nThe input variable is normally an rr::SVector{3, T}. This rr need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when norm(rr) != 1.\n\nmaxL : maximum degree of the spherical harmonics\nT : type used to store the coefficients for the associated legendre functions\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.ChebBasis","page":"Docstrings","title":"Polynomials4ML.ChebBasis","text":"ChebBasis(N): \n\nChebyshev polynomials up to degree N-1 (inclusive). i.e  basis with length N. The basis is ordered as \n\n1 x 2x^2-1 4x^3-3x  2xT_N-1(x)-T_N-2(x)\n\nwhere x is input variable. \n\nThe differences between ChebBasis and chebyshev_basis is that ChebBasis computes the basis on the go when it is compiled and it does not store the recursion coefficients as in chebyshev_basis.\n\nWarning: ChebBasis and chebyshev_basis have different normalization.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.LinearLayer","page":"Docstrings","title":"Polynomials4ML.LinearLayer","text":"struct LinearLayer : This lux layer returns W * x if feature_first is true, otherwise it returns x * transpose(W), where W is the weight matrix`.\n\nx::AbstractMatrix of size (in_dim, N) or (N, in_dim), where in_dim = feature dimension, N = batch size\nW::AbstractMatrix of size (out_dim, in_dim)\n\nConstructor\n\nLinearLayer(in_dim, out_dim; feature_first = false)\n\nExample\n\nin_d, out_d = 4, 3 # feature dimensions\nN = 10 # batch size\n\n# feature_first = true\nl = P4ML.LinearLayer(in_d, out_d; feature_first = true)\nps, st = LuxCore.setup(MersenneTwister(1234), l)\nx = randn(in_d, N) # feature-first\nout, st = l(x, ps, st)\nprintln(out == W * x) # true\n\n# feature_first = false\nl2 = P4ML.LinearLayer(in_d, out_d; feature_first = true)\nps2, st2 = LuxCore.setup(MersenneTwister(1234), l2)\nx = randn(N, in_d) # batch-first\nout, st = l(x, ps, st)\nprintln(out == x * transpose(W))) # true\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.MonoBasis","page":"Docstrings","title":"Polynomials4ML.MonoBasis","text":"Standard Monomials basis. This should very rarely be used. Possibly useful in combination with a transformation of the inputs, e.g. exponential.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.OrthPolyBasis1D3T","page":"Docstrings","title":"Polynomials4ML.OrthPolyBasis1D3T","text":"OrthPolyBasis1D3T: defines a basis of polynomials in terms of a 3-term recursion, \n\nbeginaligned\n   P_1(x) = A_1  \n   P_2 = A_2 x + B_2 \n   P_n = (A_n x + B_n) P_n-1(x) + C_n P_n-2(x)\nendaligned\n\nTypically (but not necessarily) such bases are obtained by orthogonalizing the monomials with respect to a user-specified distribution, which can be either continuous or discrete but must have a density function. See also \n\nlegendre_basis\nchebyshev_basis\njacobi_basis\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.PooledSparseProduct","page":"Docstrings","title":"Polynomials4ML.PooledSparseProduct","text":"struct PooledSparseProduct :  This implements a fused (tensor) product and pooling operation. Suppose  we are given N embeddings phi^(i)_k_i then the pooled sparse product  generates feature vectors of the form \n\nA_k_1 dots k_N = sum_j prod_t = 1^N phi^(t)_k_t(x_j)\n\nwhere x_j are an list of inputs (multi-set). \n\nConstructor\n\nPooledSparseProduct(spec)\n\nwhere spec is a list of (k_1 dots k_N) tuples or vectors, or  AbstractMatrix where each column specifies such a tuple. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.RRlmBasis","page":"Docstrings","title":"Polynomials4ML.RRlmBasis","text":"real spherical harmonics:\n\nYₗ⁰ = P̄ₗ⁰/√2 Yₗᵐ =  Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Yₗ⁻ᵐ = -Im(P̄ₗᵐ(cosθ)/√2 exp(imφ))\n\nsolid harmonics:\n\nSₗ⁰ = √(4π/2l+1) rˡP̄ₗ⁰/√2 Sₗᵐ = (-1)ᵐ√(8π/2l+1) rˡ Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Sₗ⁻ᵐ = (-1)ᵐ√(8π/2l+1) rˡIm(P̄ₗᵐ(cosθ)/√2 exp(imφ))\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.RTrigBasis","page":"Docstrings","title":"Polynomials4ML.RTrigBasis","text":"RTrigBasis(N): \n\nReal trigonometric polynomials up to degree N (inclusive). The basis is ordered as \n\n[1, cos(θ), sin(θ), cos(2θ), sin(2θ), ..., cos(Nθ), sin(Nθ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.RYlmBasis","page":"Docstrings","title":"Polynomials4ML.RYlmBasis","text":"RYlmBasis(maxL, T=Float64):\n\nReal spherical harmonics; see tests to see how they are normalized, and  idx2lm on how they are ordered. The ordering is not guarenteed to be semver-stable.\n\nThe input variable is normally an rr::SVector{3, T}. This rr need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when norm(rr) != 1.\n\nmaxL : maximum degree of the spherical harmonics\nT : type used to store the coefficients for the associated legendre functions\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SimpleProdBasis","page":"Docstrings","title":"Polynomials4ML.SimpleProdBasis","text":"Naive implementation of the product basis, intended only for testing\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SparseProduct","page":"Docstrings","title":"Polynomials4ML.SparseProduct","text":"SparseProduct : a model layer to build tensor products\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SparseSymmProd","page":"Docstrings","title":"Polynomials4ML.SparseSymmProd","text":"SparseSymmProd : sparse symmetric product with entries stored as tuples.  Input is a vector A; each entry of the output vector AA is of the form \n\n bm A_i_1 dots i_N = prod_t = 1^N A_i_t\n\nConstructor\n\nSparseSymmProd(spec)\n\nwhere spec is a list of tuples or vectors, each of which specifies an AA basis function as described above. For example, \n\nspec = [ (1,), (2,), (1,1), (1,2), (2,2), \n         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]\nbasis = SparseSymmProd(spec)         \n\ndefines a basis of 9 functions, \n\n A_1 A_2 A_1^2 A_1 A_2 A_2^2 A_1^3 A_1^2 A_2 A_1 A_2^2 A_2^3 \n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SparseSymmProdDAG","page":"Docstrings","title":"Polynomials4ML.SparseSymmProdDAG","text":"struct SparseSymmProdDAG : alternative (recursive) implementation of  SparseSymmProd. This has better theoretical performance for high correlation  orders. \n\nThe potential downside is that it inserts auxiliary basis functions into the  basis. This means, that the specification of the output will be different  from the specification that is used to construct the basis. To that end, the  field projection can be used to reduce it back to the original spec. E.g., \n\nbasis = SparseSymmProd(spec)\nbasis_dag = SparseSymmProdDAG(spec)\nA = randn(nA)\nbasis(A) ≈ basis_dag(A)[basis_dag.projection]   # true\n\nHowever, the field projection is used only for information, and not  to actually reduce the output. One could of course use it to compose  the output with a projection matrix.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML.SparseSymmProdDAG-Tuple{AbstractVector}","page":"Docstrings","title":"Polynomials4ML.SparseSymmProdDAG","text":"Construct the DAG used to evaluate an AA basis and returns it as a SparseSymmProdDAG\n\nArguments\n\nspec : AA basis specification, list of vectors of integers / indices pointing into A \n\nKwargs: \n\nfilter = _-> true : \nverbose = false : print some information about the \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.SphericalCoords","page":"Docstrings","title":"Polynomials4ML.SphericalCoords","text":"struct SphericalCoords : a simple datatype storing spherical coordinates of a point (x,y,z) in the format (r, cosφ, sinφ, cosθ, sinθ). Use spher2cart and cart2spher to convert between cartesian and spherical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}","page":"Docstrings","title":"Polynomials4ML._init_luxparams","text":"a fall-back method for initalparameters that all AbstractPoly4MLBasis should overload \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, CRlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.cRlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, Polynomials4ML.SphericalCoords{T}, AbstractVector, CRlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.cRlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CRlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.cRlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, CRlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.cRlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, CYlmBasis}","page":"Docstrings","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, Any}} where T","page":"Docstrings","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, CYlmBasis}","page":"Docstrings","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.cYlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CYlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.chebyshev_basis-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.chebyshev_basis","text":"chebyshev_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Chebyshev polynomials of the first kind. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.dspher_to_dcart-Tuple{Any, Any, Any}","page":"Docstrings","title":"Polynomials4ML.dspher_to_dcart","text":"convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.idx2l-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.idx2l","text":"Partial inverse of lm2idx: given an index into a vector of Ylm values, return the  l index. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.idx2lm-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.idx2lm","text":"Inverse of lm2idx: given an index into a vector of Ylm values, return the  l, m indices.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.index_p-Tuple{Integer, Integer}","page":"Docstrings","title":"Polynomials4ML.index_p","text":"index_p(l,m): Return the index into a flat array of Associated Legendre Polynomials P_l^m for the given indices (l,m). P_l^m are stored in l-major order i.e. \n\n\t[P(0,0), [P(1,0), P(1,1), P(2,0), ...]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.jacobi_basis-Tuple{Integer, Real, Real}","page":"Docstrings","title":"Polynomials4ML.jacobi_basis","text":"jacobi_basis(N::Integer, α::Real, β::Real): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Jacobi polynomials Jαβ. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.legendre_basis-Tuple{Integer}","page":"Docstrings","title":"Polynomials4ML.legendre_basis","text":"legendre_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Legendre polynomials (L2 orthonormal on [-1, 1]). N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.lm2idx-Tuple{Integer, Integer}","page":"Docstrings","title":"Polynomials4ML.lm2idx","text":"lm2idx(l,m): Return the index into a flat array of real spherical harmonics Y_lm for the given indices (l,m). Y_lm are stored in l-major order i.e.\n\n\t[Y(0,0), Y(1,-1), Y(1,0), Y(1,1), Y(2,-2), ...]\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.lux-Tuple{Polynomials4ML.AbstractPoly4MLBasis}","page":"Docstrings","title":"Polynomials4ML.lux","text":"lux(basis) : convert a basis / embedding object into a lux layer. This assumes  that the basis accepts a number or short vector as input and produces an output  that is a vector. It also assumes that batched operations are implemented,  as well as some other functionality. \n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.maxL-Tuple{Union{CRlmBasis, CYlmBasis, RRlmBasis, RYlmBasis}}","page":"Docstrings","title":"Polynomials4ML.maxL","text":"max L degree for which the alp coefficients have been precomputed\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.orthpolybasis-Union{Tuple{TW}, Tuple{Integer, Polynomials4ML.DiscreteWeights{TW}}} where TW","page":"Docstrings","title":"Polynomials4ML.orthpolybasis","text":"function orthpolybasis(...) : construct a univariate orthogonal polynomial  basis with respect to some specified inner product. For the standard 3-term  recursion polynomials, use legendre_basis, jacobi_basis or chebyshev_basis. \n\nThe orthpolybasis currently implements orthogonal polynomials for discrete weights with the following constructors: \n\northpolybasis(N::Integer, W::DiscreteWeights{TW}; TX = Float64)\northpolybasis(N::Integer, X::AbstractVector{<: Real}, \n              W::AbstractVector{<: Real}, normalizeW=false; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rRlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, RRlmBasis}","page":"Docstrings","title":"Polynomials4ML.rRlm!","text":"evaluate real solid harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, RRlmBasis}} where T","page":"Docstrings","title":"Polynomials4ML.rRlm_ed!","text":"evaluate gradients of real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rYlm!-Tuple{Any, Any, Any, AbstractVector, RYlmBasis}","page":"Docstrings","title":"Polynomials4ML.rYlm!","text":"evaluate real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.rYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, RYlmBasis}","page":"Docstrings","title":"Polynomials4ML.rYlm_ed!","text":"evaluate gradients of real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.sizeP-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.sizeP","text":"sizeP(maxL):  Return the size of the set of Associated Legendre Polynomials P_l^m(x) of degree less than or equal to the given maximum degree\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.sizeY-Tuple{Any}","page":"Docstrings","title":"Polynomials4ML.sizeY","text":"sizeY(maxL): Return the size of the set of spherical harmonics Y_lm(θφ) of degree less than or equal to the given maximum degree maxL\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.Utils._gensparse-Union{Tuple{NU}, Tuple{Val{NU}, Vararg{Any, 7}}} where NU","page":"Docstrings","title":"Polynomials4ML.Utils._gensparse","text":"_gensparse : function barrier for gensparse\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Polynomials4ML.Utils.gensparse-Tuple{}","page":"Docstrings","title":"Polynomials4ML.Utils.gensparse","text":"gensparse(...) : utility function to generate high-dimensional sparse grids which are downsets. All arguments are keyword arguments (with defaults):\n\nNU : maximum correlation order\nminvv = 0 : minvv[i] gives the minimum value forvv[i]`\nmaxvv = Inf : maxvv[i] gives the minimum value forvv[i]`\ntup2b = vv -> vv :\nadmissible = _ -> false : determines whether a tuple belongs to the downset\nfilter = _ -> true : a callable object that returns true of tuple is to be kept and\n\nfalse otherwise (whether or not it is part of the downset!) This is used, e.g. to enfore conditions such as ∑ lₐ = even or |∑ mₐ| ≦ M\n\nINT = Int : integer type to be used\nordered = false : whether only ordered tuples are produced; ordered tuples\n\ncorrespond to  permutation-invariant basis functions\n\n\n\n\n\n","category":"method"}]
}
