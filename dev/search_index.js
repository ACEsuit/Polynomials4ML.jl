var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This page documents the public API, i.e. the list of bases and functions that are considered relatively stable and for which we aim to strictly impose semver backward compatibility. The basis sets that are considered stable are the following (please see inline documentation for initialization): ","category":"page"},{"location":"api/","page":"API","title":"API","text":"Several classes of orthogonal polynomials OrthPolyBasis1D3T\nGeneral Jacobi jacobi_basis\nLegendre legendre_basis\nChebyshev chebyshev_basis\nDiscrete distribution orthpolybasis \n2D harmonics: \nComplex trigonometric polynomials CTrigBasis\nReal trigonometric polynomials RTrigBasis\n3D harmonics: \nComplex spherical harmonics CYlmBasis\nReal spherical harmonics RYlmBasis\nComplex solid harmonics CRlmBasis\nReal solid harmonics RRlmBasis\nChebyshev polynomials of the first kind ChebBasis\nVarious quantum chemistry related radial basis functions. (experimental)","category":"page"},{"location":"api/#In-place-Evaluation","page":"API","title":"In-place Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the in-place evaluation interface. All basis sets implemented in this package should provide this interface as a minimal requirement. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"evaluate!(P, basis, X)\nevaluate_ed!(P, dP, basis, X)\nevaluate_ed2!(P, dP, ddP, basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"basis : an object defining one of the basis sets \nX : a single input or array of inputs. \nP : array containing the basis values \ndP : array containing derivatives of basis w.r.t. inputs \nddP : array containing second derivatives of basis w.r.t. inputs ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then this should normally be a Number or a StaticArray to distinguish it from collections of inputs. X can also be an AbstractArray of admissible inputs, e.g., Vector{<: Number}. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"If X is a single input then P, dP, ddP will be AbstractVector. If X is an AbstractVector of inputs then P, dP, ddP must be AbstractMatrix, and so forth. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The output arrays P, dP, ddP must be sufficiently large in each dimension to accomodate the size of the input and the size of the basis, but the sizes need not match exactly. It is up to the caller to ensure matching array sizes if this is needed.","category":"page"},{"location":"api/#Allocating-Evaluation","page":"API","title":"Allocating Evaluation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This section documents the allocating evaluation interface. All basis sets should implement this interface.","category":"page"},{"location":"api/","page":"API","title":"API","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)\nP, dP, ddP = evaluate_ed2(basis, X)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The output types of P, dP, ddP are guarnateed to be AbstractArrays but may otherwise change between package versions. The exact type should not be relied upon when using this package. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The meaning of the different symbols is exactly the same as described above. The only difference is that the output containers P, dP, ddP are now allocated.  Their type should be stable (if not, please file a bug report), but unspecified in the sense that the output type is not semver-stable for the time being.  If you need a sem-ver stable output then it is best to follow the above with a collect.","category":"page"},{"location":"backup/","page":"-","title":"-","text":"Polynomials4ML.OrthPolyBasis1D3T\nPolynomials4ML.chebyshev_basis\nPolynomials4ML.legendre_basis\nPolynomials4ML.jacobi_basis\nPolynomials4ML.MonoBasis\nPolynomials4ML.CTrigBasis\nPolynomials4ML.RTrigBasis\nPolynomials4ML.CYlmBasis\nPolynomials4ML.RYlmBasis\nPolynomials4ML.ChebBasis","category":"page"},{"location":"backup/#Polynomials4ML.OrthPolyBasis1D3T","page":"-","title":"Polynomials4ML.OrthPolyBasis1D3T","text":"OrthPolyBasis1D3T: defines a basis of polynomials in terms of a 3-term recursion, \n\nbeginaligned\n   P_1(x) = A_1  \n   P_2 = A_2 x + B_2 \n   P_n = (A_n x + B_n) P_n-1(x) + C_n P_n-2(x)\nendaligned\n\nTypically (but not necessarily) such bases are obtained by orthogonalizing the monomials with respect to a user-specified distribution, which can be either continuous or discrete but must have a density function. See also \n\nlegendre_basis\nchebyshev_basis\njacobi_basis\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.chebyshev_basis","page":"-","title":"Polynomials4ML.chebyshev_basis","text":"chebyshev_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Chebyshev polynomials of the first kind. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"function"},{"location":"backup/#Polynomials4ML.legendre_basis","page":"-","title":"Polynomials4ML.legendre_basis","text":"legendre_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Legendre polynomials (L2 orthonormal on [-1, 1]). N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"function"},{"location":"backup/#Polynomials4ML.jacobi_basis","page":"-","title":"Polynomials4ML.jacobi_basis","text":"jacobi_basis(N::Integer, α::Real, β::Real): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Jacobi polynomials Jαβ. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"function"},{"location":"backup/#Polynomials4ML.MonoBasis","page":"-","title":"Polynomials4ML.MonoBasis","text":"Standard Monomials basis. This should very rarely be used. Possibly useful in combination with a transformation of the inputs, e.g. exponential.\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.CTrigBasis","page":"-","title":"Polynomials4ML.CTrigBasis","text":"Complex trigonometric polynomials up to degree N (inclusive). The basis is  constructed in the order \n\n[1, exp(im*θ), exp(-im*θ), exp(2im*θ), exp(-2im*θ), ..., \n                                exp(N*im*θ), exp(-N*im*θ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.RTrigBasis","page":"-","title":"Polynomials4ML.RTrigBasis","text":"RTrigBasis(N): \n\nReal trigonometric polynomials up to degree N (inclusive). The basis is ordered as \n\n[1, cos(θ), sin(θ), cos(2θ), sin(2θ), ..., cos(Nθ), sin(Nθ) ]\n\nwhere θ is input variable. \n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.CYlmBasis","page":"-","title":"Polynomials4ML.CYlmBasis","text":"CYlmBasis(maxL, T=Float64):\n\nComplex spherical harmonics; see tests to see how they are normalized, and  idx2lm on how they are ordered. The ordering is not guarenteed to be semver-stable.\n\nThe input variable is normally an rr::SVector{3, T}. This rr need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when norm(rr) != 1.\n\nmaxL : maximum degree of the spherical harmonics\nT : type used to store the coefficients for the associated legendre functions\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.RYlmBasis","page":"-","title":"Polynomials4ML.RYlmBasis","text":"RYlmBasis(maxL, T=Float64):\n\nReal spherical harmonics; see tests to see how they are normalized, and  idx2lm on how they are ordered. The ordering is not guarenteed to be semver-stable.\n\nThe input variable is normally an rr::SVector{3, T}. This rr need not be normalized (i.e. on the unit sphere). The derivatives account for this, i.e. they are valid even when norm(rr) != 1.\n\nmaxL : maximum degree of the spherical harmonics\nT : type used to store the coefficients for the associated legendre functions\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.ChebBasis","page":"-","title":"Polynomials4ML.ChebBasis","text":"ChebBasis(N): \n\nChebyshev polynomials up to degree N-1 (inclusive). i.e  basis with length N. The basis is ordered as \n\n1 x 2x^2-1 4x^3-3x  2xT_N-1(x)-T_N-2(x)\n\nwhere x is input variable. \n\nThe differences between ChebBasis and chebyshev_basis is that ChebBasis computes the basis on the go when it is compiled and it does not store the recursion coefficients as in chebyshev_basis.\n\nWarning: ChebBasis and chebyshev_basis have different normalization.\n\n\n\n\n\n","category":"type"},{"location":"backup/","page":"-","title":"-","text":"Modules = [Polynomials4ML]","category":"page"},{"location":"backup/#Polynomials4ML.ALPolynomials","page":"-","title":"Polynomials4ML.ALPolynomials","text":"ALPolynomials : an auxiliary datastructure for evaluating the associated Legendre functions used for the spherical and solid harmonics. Constructor:\n\nALPolynomials(maxL::Integer, T::Type=Float64)\n\nThis is not part of the public API and not guaranteed to be semver-stable. Only the resulting harmonics that use the ALPs are guaranteed to be backward  compatible. \n\nImportant Note: evaluate_ed!` does NOT return derivatives, but rather  produces rescaled derivatives for better numerical stability near the poles.  See comments in code for details on how to use the ALP derivatives correctly. \n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.CRlmBasis","page":"-","title":"Polynomials4ML.CRlmBasis","text":"complex spherical harmonics: \n\nYₗ⁰(θ, φ) = P̄ₗ⁰(cosθ)/√2 Yₗᵐ(θ, φ) = P̄ₗᵐ(cosθ)exp(imφ)/√2 Yₗ⁻ᵐ(θ, φ) = (-1)ᵐ P̄ₗᵐ(cosθ)/√2 exp(-imφ)\n\nsolid harmonics:\n\nγₗᵐ(r, θ, φ) = rˡYₗᵐ(θ, φ)\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.LinearLayer","page":"-","title":"Polynomials4ML.LinearLayer","text":"struct LinearLayer : This lux layer returns W * x if feature_first is true, otherwise it returns x * transpose(W), where W is the weight matrix` where \n\nx::AbstractMatrix of size (in_dim, N) or (N, in_dim), where in_dim = feature dimension, N = batch size\nW::AbstractMatrix of size (out_dim, in_dim)\n\nConstructor\n\nLinearLayer(in_dim, out_dim; feature_first = false)\n\nFor example\n\nin_d, out_d = 4, 3 # feature dimensions\nN = 10 # batch size\n\n# feature_first = true\nl = P4ML.LinearLayer(in_d, out_d; feature_first = true)\nps, st = LuxCore.setup(MersenneTwister(1234), l)\nx = randn(in_d, N) # feature-first\nout, st = l(x, ps, st)\nprintln(out == W * x) # true\n\n# feature_first = false\nl2 = P4ML.LinearLayer(in_d, out_d; feature_first = true)\nps2, st2 = LuxCore.setup(MersenneTwister(1234), l2)\nx = randn(N, in_d) # batch-first\nout, st = l(x, ps, st)\nprintln(out == x * transpose(W))) # true\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.RRlmBasis","page":"-","title":"Polynomials4ML.RRlmBasis","text":"real spherical harmonics:\n\nYₗ⁰ = P̄ₗ⁰/√2 Yₗᵐ =  Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Yₗ⁻ᵐ = -Im(P̄ₗᵐ(cosθ)/√2 exp(imφ))\n\nsolid harmonics:\n\nSₗ⁰ = √(4π/2l+1) rˡP̄ₗ⁰/√2 Sₗᵐ = (-1)ᵐ√(8π/2l+1) rˡ Re(P̄ₗᵐ(cosθ)/√2 exp(imφ)) Sₗ⁻ᵐ = (-1)ᵐ√(8π/2l+1) rˡIm(P̄ₗᵐ(cosθ)/√2 exp(imφ))\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.SimpleProdBasis","page":"-","title":"Polynomials4ML.SimpleProdBasis","text":"Naive implementation of the product basis, intended only for testing\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.SparseSymmProd","page":"-","title":"Polynomials4ML.SparseSymmProd","text":"SparseSymmProd : sparse symmetric product with entries stored as tuples.  Input is a vector A; each entry of the output vector AA is of the form \n\n bm A_i_1 dots i_N = prod_t = 1^N A_i_t\n\nConstructor\n\nSparseSymmProd(spec)\n\nwhere spec is a list of tuples or vectors, each of which specifies an AA basis function as described above. For example, \n\nspec = [ (1,), (2,), (1,1), (1,2), (2,2), \n         (1,1,1), (1,1,2), (1,2,2), (2,2,2) ]\nbasis = SparseSymmProd(spec)         \n\ndefines a basis of 9 functions, \n\n A_1 A_2 A_1^2 A_1 A_2 A_2^2 A_1^3 A_1^2 A_2 A_1 A_2^2 A_2^3 \n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.SparseSymmProdDAG","page":"-","title":"Polynomials4ML.SparseSymmProdDAG","text":"struct SparseSymmProdDAG : alternative (recursive) implementation of  SparseSymmProd. This has better theoretical performance for high correlation  orders. \n\nThe potential downside is that it inserts auxiliary basis functions into the  basis. This means, that the specification of the output will be different  from the specification that is used to construct the basis. To that end, the  field projection can be used to reduce it back to the original spec. E.g., \n\nbasis = SparseSymmProd(spec)\nbasis_dag = SparseSymmProdDAG(spec)\nA = randn(nA)\nbasis(A) ≈ basis_dag(A)[basis_dag.projection]   # true\n\nHowever, the field projection is used only for information, and not  to actually reduce the output. One could of course use it to compose  the output with a projection matrix.\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML.SparseSymmProdDAG-Tuple{AbstractVector}","page":"-","title":"Polynomials4ML.SparseSymmProdDAG","text":"Construct the DAG used to evaluate an AA basis and returns it as a SparseSymmProdDAG\n\nArguments\n\nspec : AA basis specification, list of vectors of integers / indices pointing into A \n\nKwargs: \n\nfilter = _-> true : \nverbose = false : print some information about the \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.SphericalCoords","page":"-","title":"Polynomials4ML.SphericalCoords","text":"struct SphericalCoords : a simple datatype storing spherical coordinates of a point (x,y,z) in the format (r, cosφ, sinφ, cosθ, sinθ). Use spher2cart and cart2spher to convert between cartesian and spherical coordinates.\n\n\n\n\n\n","category":"type"},{"location":"backup/#Polynomials4ML._init_luxparams-Tuple{Random.AbstractRNG, Any}","page":"-","title":"Polynomials4ML._init_luxparams","text":"a fall-back method for initalparameters that all AbstractPoly4MLBasis should overload \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, CRlmBasis}} where T","page":"-","title":"Polynomials4ML.cRlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cRlm!-Union{Tuple{T}, Tuple{Any, Any, Polynomials4ML.SphericalCoords{T}, AbstractVector, CRlmBasis}} where T","page":"-","title":"Polynomials4ML.cRlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CRlmBasis}} where T","page":"-","title":"Polynomials4ML.cRlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, CRlmBasis}} where T","page":"-","title":"Polynomials4ML.cRlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cYlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, CYlmBasis}","page":"-","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cYlm!-Union{Tuple{T}, Tuple{Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, Any}} where T","page":"-","title":"Polynomials4ML.cYlm!","text":"evaluate complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, CYlmBasis}","page":"-","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.cYlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, AbstractArray{Polynomials4ML.SphericalCoords{T}, 1}, AbstractMatrix, AbstractMatrix, CYlmBasis}} where T","page":"-","title":"Polynomials4ML.cYlm_ed!","text":"evaluate gradients of complex spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.chebyshev_basis-Tuple{Integer}","page":"-","title":"Polynomials4ML.chebyshev_basis","text":"chebyshev_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Chebyshev polynomials of the first kind. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.dspher_to_dcart-Tuple{Any, Any, Any}","page":"-","title":"Polynomials4ML.dspher_to_dcart","text":"convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.idx2l-Tuple{Integer}","page":"-","title":"Polynomials4ML.idx2l","text":"Partial inverse of lm2idx: given an index into a vector of Ylm values, return the  l index. \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.idx2lm-Tuple{Integer}","page":"-","title":"Polynomials4ML.idx2lm","text":"Inverse of lm2idx: given an index into a vector of Ylm values, return the  l, m indices.\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.index_p-Tuple{Integer, Integer}","page":"-","title":"Polynomials4ML.index_p","text":"index_p(l,m): Return the index into a flat array of Associated Legendre Polynomials P_l^m for the given indices (l,m). P_l^m are stored in l-major order i.e. \n\n\t[P(0,0), [P(1,0), P(1,1), P(2,0), ...]\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.jacobi_basis-Tuple{Integer, Real, Real}","page":"-","title":"Polynomials4ML.jacobi_basis","text":"jacobi_basis(N::Integer, α::Real, β::Real): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Jacobi polynomials Jαβ. N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.legendre_basis-Tuple{Integer}","page":"-","title":"Polynomials4ML.legendre_basis","text":"legendre_basis(N::Integer): \n\nConstructs an OrthPolyBasis1D3T object representing a possibly rescaled version of the basis of Legendre polynomials (L2 orthonormal on [-1, 1]). N is the length of the basis, not the degree. \n\nCareful: the normalisation may be non-standard. \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.lm2idx-Tuple{Integer, Integer}","page":"-","title":"Polynomials4ML.lm2idx","text":"lm2idx(l,m): Return the index into a flat array of real spherical harmonics Y_lm for the given indices (l,m). Y_lm are stored in l-major order i.e.\n\n\t[Y(0,0), Y(1,-1), Y(1,0), Y(1,1), Y(2,-2), ...]\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.lux-Tuple{Polynomials4ML.AbstractPoly4MLBasis}","page":"-","title":"Polynomials4ML.lux","text":"lux(basis) : convert a basis / embedding object into a lux layer. This assumes  that the basis accepts a number or short vector as input and produces an output  that is a vector. It also assumes that batched operations are implemented,  as well as some other functionality. \n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.maxL-Tuple{Union{CRlmBasis, CYlmBasis, RRlmBasis, RYlmBasis}}","page":"-","title":"Polynomials4ML.maxL","text":"max L degree for which the alp coefficients have been precomputed\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.rRlm!-Tuple{Any, Any, Polynomials4ML.SphericalCoords, AbstractVector, RRlmBasis}","page":"-","title":"Polynomials4ML.rRlm!","text":"evaluate real solid harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.rRlm_ed!-Union{Tuple{T}, Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords{T}, Any, Any, RRlmBasis}} where T","page":"-","title":"Polynomials4ML.rRlm_ed!","text":"evaluate gradients of real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.rYlm!-Tuple{Any, Any, Any, AbstractVector, RYlmBasis}","page":"-","title":"Polynomials4ML.rYlm!","text":"evaluate real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.rYlm_ed!-Tuple{Any, Any, Any, Polynomials4ML.SphericalCoords, Any, Any, RYlmBasis}","page":"-","title":"Polynomials4ML.rYlm_ed!","text":"evaluate gradients of real spherical harmonics\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.sizeP-Tuple{Any}","page":"-","title":"Polynomials4ML.sizeP","text":"sizeP(maxL):  Return the size of the set of Associated Legendre Polynomials P_l^m(x) of degree less than or equal to the given maximum degree\n\n\n\n\n\n","category":"method"},{"location":"backup/#Polynomials4ML.sizeY-Tuple{Any}","page":"-","title":"Polynomials4ML.sizeY","text":"sizeY(maxL): Return the size of the set of spherical harmonics Y_lm(θφ) of degree less than or equal to the given maximum degree maxL\n\n\n\n\n\n","category":"method"},{"location":"experimental/#Experimental-API","page":"Experimental","title":"Experimental API","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The interfaces specified below are experimental and not part of the public API yet. Some of it is not even implemented yet and are just being sketched out in separate branches. There is no guarantee that these are provided for all of the exported basis sets, and there is no guarantee of semver-compatible backward compatibility at this point.","category":"page"},{"location":"experimental/#Re-using-Basis-Output-Arrays","page":"Experimental","title":"Re-using Basis Output Arrays","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The default output arrays are of type CachedArray. This means that after they have been used, they can be released back into an array cache from which they have been acquired. (See ObjectPools.jl for more details.) This will avoid a new allocation next time a basis is evaluated. The interface for this is ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"B = evaluate(basis, X)\nrelease!(B)\nB, dB = evaluate_ed(basis, X)\nrelease!(B)\nrelease!(dB)\n# ... and so forth ... ","category":"page"},{"location":"experimental/#Laplacian","page":"Experimental","title":"Laplacian","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"The laplacian interface is experimental and should not be considered part of the public API. ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"For some applications it is important to have a fast evaluation of the laplace operator, which can often be achieved at far lower computational cost than a hessian. For example, spherical harmonics are eigenfunctions of the laplacian while solid harmonics have zero-laplacian. To exploit this we provide both in-place and allocating interfaces to evaluate the laplacians. In addition we provide an interface to evaluate the basis, its gradients as well as the laplacian, analogous to evaluate_ed2 above. This interface is convenient to evaluate laplacians of chains.","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"laplacian!(ΔY, basis, X)\nΔY = laplacian(basis, X)\neval_grad_laplace!(Y, dY, ΔY, basis, X)\nY, dY, ΔY = eval_grad_laplace(basis, X)","category":"page"},{"location":"experimental/#(Atomic)-Cluster-Expansion","page":"Experimental","title":"(Atomic) Cluster Expansion","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"Two key operations are probided that are needed for the implementation of the (atomic) cluster expansion. The precise deficitions and interface may still change, so those are also still labelled experimental. ","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"PooledSparseProduct : implements a merged product basis and pooling operation; in the atomic cluster expansion this is called the atomic basis; in GAP it is called the density projection.\nSparseSymmProd : implements a sparse symmetric rank-1 tensor product, in ACE this is called the product basis, in GAP the n-correlations.","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"Both of those operations have pullbacks implemented, but not evaluate_ed! or evaluate_ed2!.","category":"page"},{"location":"experimental/#Backward-Differentiation-w.r.t.-Inputs-X","page":"Experimental","title":"Backward Differentiation w.r.t. Inputs X","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"[WORK IN PROGRESS] We implement \"manual\" pullbacks w.r.t. the X variable. These  take the form","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"∂X = pb_evaluate(basis, ∂B, X, args...)\npb_evaluate!(∂X, basis, ∂B, X, args...)","category":"page"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"and analogously for the evaluate_*** variants. The args... can differ between different basis sets e.g. may rely on intermediate results in the evaluation of the basis. ","category":"page"},{"location":"experimental/#Lux","page":"Experimental","title":"Lux","text":"","category":"section"},{"location":"experimental/","page":"Experimental","title":"Experimental","text":"[TODO] describe the lux layer interface as it evolves ... ","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Polynomials4ML","category":"page"},{"location":"#Polynomials4ML","page":"Home","title":"Polynomials4ML","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Polynomials4ML.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\", \"experimental.md\", \"docstrings.md\"]\nDepth = 3","category":"page"},{"location":"SH/#Spherical-Harmonics","page":"-","title":"Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"This section provides documentation for the evaluation of complex and real spherical harmonics and solid harmonics, including gradient and Laplacian calculations. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Associated Legendre Polynomials\nComplex Spherical Harmonics\nComplex Solid Harmonics\nReal Spherical Harmonics\nReal Solid Harmonics","category":"page"},{"location":"SH/#Associated-Legendre-Polynomials","page":"-","title":"Associated Legendre Polynomials","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"Associated Legendre polynomials P_ell^m are closely related to the spherical harmonics, P_ell^m of degree ell and order mgeq 0 are defined as (in the phase convention of Condon and Shortley) $ \\begin{aligned} P{\\ell}^m(x) = \\frac{(-1)^m}{2^{\\ell}\\ell!}(1-x^2)^{m/2}\\frac{\\mathrm{d}^{\\ell+m}}{\\mathrm{d}x^{\\ell+m}}(x^2-1)^{\\ell}. \\end{aligned} $ The negative order can be related to the corresponding positive order via a proportionality constant that involves only ell and m,  $ \\begin{aligned} P{\\ell}^{-m}(x) = (-1)^m \\frac{(\\ell-m)!}{(\\ell+m)!}P{\\ell}^m(x).  \\end{aligned} $ The associated Legendre polynomials are orthogonal on the interval -1leq xleq 1 in the sense that  $ \\begin{aligned} \\int{-1}^{1} P{k}^m(x) P{\\ell}^m(x) \\mathrm{d}x = \\frac{2}{2\\ell+1}\\frac{(\\ell+m)!}{(\\ell-m)!}\\delta_{k\\ell}.  \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"In alp.jl, Polynomials4ML utilizes the following normalization for the associated Legendre polynomials,   $ \\begin{aligned} \\bar{P}{\\ell}^{m}(x) = \\sqrt{\\frac{(2\\ell+1)(\\ell-m)!}{2\\pi (\\ell+m)!}}P{\\ell}^m, \\qquad m\\geq 0 \\end{aligned} $ and one can generate a data structure as ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"ALPs = ALPolynomials(maxL::Integer, T::Type=Float64)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"where maxL specifies the maximum degree of the polynomials. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"The associated Legendre polynomials allow for ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"X is a point in spherical coordinates, P and dp stores P_l^m(X.cosθ) and dP_l^m(X.cosθ). Specifically, only non-negative m terms are stored, and are arranged in ell-major order. To retrieve the specific values of P_l^m and dP_l^m for given indices (l, m), one can use","category":"page"},{"location":"SH/","page":"-","title":"-","text":"index_p(l,m)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"The algorithm for computing associated Legendre polynomials is based on Dusson(2022) eq.(A.7), where A_l^m, B_l^m, C_l^m can be found in Limpanuparb(2014) eq.(7)-(14). ","category":"page"},{"location":"SH/#Condon-Shortley-Sign-Convention","page":"-","title":"Condon-Shortley Sign Convention","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"There are two sign conventions for associated Legendre polynomials. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} P_{\\ell}^m(x) = \\frac{(-1)^m}{2^{\\ell}\\ell!}(1-x^2)^{m/2}\\frac{\\mathrm{d}^{\\ell+m}}{\\mathrm{d}x^{\\ell+m}}(x^2-1)^{\\ell}. \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} P{\\ell}^m(x) = \\frac{1}{2^{\\ell}\\ell!}(1-x^2)^{m/2}\\frac{\\mathrm{d}^{\\ell+m}}{\\mathrm{d}x^{\\ell+m}}(x^2-1)^{\\ell}. \\end{aligned} $ One possible way to distinguish the two conventions is $ \\begin{aligned} P{\\ell m}(x) = (-1)^m P_{\\ell}^m(x).  \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"The Condon-Shortley sign convention enables us to establish the following relationships between spherical harmonics and angular momentum ladder operators $ \\begin{aligned} Y{\\ell}^m(\\theta, \\varphi) &= A{\\ell m}\\hat{L}-^{\\ell-m}Y{\\ell}^{\\ell}(\\theta, \\varphi), \\\nY{\\ell}^m(\\theta, \\varphi) &= A{\\ell, -m}\\hat{L}+^{\\ell+m}Y{\\ell}^{-\\ell}(\\theta, \\varphi),  \\end{aligned} $ with all positive constants A_ell m = sqrtfrac(ell+m)(2ell)(ell+m). Ignoring the Condon-Shortley phase would introduce signs into the A_ell m. It's only a sign convention. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Including the factor of (-1)^m and written in terms x=costheta,  the first few associated Legendre polynomials are  | mbackslashell | 0         | 1          | 2         | 3          | |–––––––––|–––––-|–––––-|–––––-|–––––-| | 3                |           |           |           | -15sin^3theta | | 2                |           |           | 3sin^2theta | 15costhetasin^2theta | | 1                |           | -sintheta | -3sinthetacostheta | -frac32(5cos^2theta - 1)sintheta | | 0                | 1         | costheta | frac12(3cos^2theta - 1) | frac12costheta(5cos^2theta-3) |","category":"page"},{"location":"SH/#Complex-Spherical-Harmonics","page":"-","title":"Complex Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"In cylm.jl, Polynomials4ML utilizes orthonormalized complex spherical harmonics that includes the Condon-Shortley phase, defined as $ \\begin{aligned} \tY{\\ell}^m(\\theta, \\varphi) = \\sqrt{\\frac{2\\ell+1}{4\\pi}\\frac{(\\ell-m)!}{(\\ell+m)!}}P{\\ell}^m(\\cos \\theta)\\mathrm{e}^{\\mathrm{i}m \\varphi}.  \\end{aligned} $ The normalization in complex spherical harmonics is chosen to satisfy $ \\begin{aligned} \t\\int0^{2\\pi}\\int0^{\\pi}Y{k}^m(\\theta, \\varphi)\\bar{Y}{\\ell}^n(\\theta, \\varphi)\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\varphi =\\delta{k\\ell}\\delta{mn}. \\end{aligned} $ Orthonormalized complex spherical harmonics that include the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"-","title":"-","text":"mbackslashell 0 1 2 3\n3    -frac18sqrtfrac35picdot mathrme^3mathrmivarphicdot sin^3theta\n2   frac14sqrtfrac152picdot mathrme^2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^2mathrmivarphicdot sin^2thetacdot costheta\n1  -frac12sqrtfrac32picdot mathrme^mathrmivarphicdot sintheta -frac12sqrtfrac152picdot mathrme^mathrmivarphicdot sintheta cdot costheta -frac18sqrtfrac21picdot mathrme^mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n0 frac12sqrtfrac1pi frac12sqrtfrac3picdot cos theta frac14sqrtfrac5picdot (3cos^2theta - 1) frac14sqrtfrac7picdot (5cos^3theta - 3costheta)\n-1  frac12sqrtfrac32picdot mathrme^-mathrmivarphicdot sintheta frac12sqrtfrac152picdot mathrme^-mathrmivarphicdot sintheta cdot costheta frac18sqrtfrac21picdot mathrme^-mathrmivarphicdot sintheta cdot (5cos^2theta-1)\n-2   frac14sqrtfrac152picdot mathrme^-2mathrmivarphicdot sin^2theta frac14sqrtfrac1052picdot mathrme^-2mathrmivarphicdot sin^2thetacdot costheta\n-3    frac18sqrtfrac35picdot mathrme^-3mathrmivarphicdot sin^3theta","category":"page"},{"location":"SH/","page":"-","title":"-","text":"To generate the complex spherical harmonics Y_ell^m with normalized associated Legendre polynomials barP_ell^m, the formulas can be rewritten as $ \\begin{aligned} \\begin{cases} Y{\\ell}^0(\\theta, \\varphi) = \\sqrt{\\frac{1}{2}}\\bar{P}{\\ell}^0(\\cos \\theta)\\\nY{\\ell}^m(\\theta, \\varphi) = \\sqrt{\\frac{1}{2}}\\bar{P}{\\ell}^m(\\cos \\theta)\\mathrm{e}^{\\mathrm{i}m \\varphi}\\\nY{\\ell}^{-m}(\\theta, \\varphi) = (-1)^m\\cdot \\sqrt{\\frac{1}{2}} \\bar{P}{\\ell}^m(\\cos \\theta)\\mathrm{e}^{-\\mathrm{i}m \\varphi} \\end{cases}, \\qquad m>0. \\end{aligned} $ To evaluate the gradients of the spherical harmonics nabla Y_ell^m, one need to convert a gradient with respect to spherical coordinates to a gradient with respect to cartesian coordinates,  $ \\begin{aligned} \\begin{cases} (\\frac{\\partial \\varphi}{\\partial x}, \\frac{\\partial \\varphi}{\\partial y}, \\frac{\\partial \\varphi}{\\partial z}) = (-\\frac{\\sin\\varphi}{r\\sin \\theta}, \\frac{\\cos\\varphi}{r\\sin \\theta}, 0)\\\n(\\frac{\\partial \\theta}{\\partial x}, \\frac{\\partial \\theta}{\\partial y}, \\frac{\\partial \\theta}{\\partial z}) = (\\frac{\\cos \\varphi \\cos \\theta}{r}, \\frac{\\sin \\varphi \\cos \\theta}{r}, -\\frac{\\sin \\theta}{r}) \\end{cases}. \\end{aligned} $ Therefore, the gradient of Y_ell^m can be expressed as, $ \\begin{aligned} \\nabla Y{\\ell}^m = \\frac{\\mathrm{i}m P{\\ell}^m \\mathrm{e}^{\\mathrm{i}m\\varphi}}{r\\sin \\theta}\\begin{bmatrix} -\\sin \\varphi \\\\cos \\varphi \\0 \\end{bmatrix} +  \\frac{\\partial{\\theta}P{\\ell}^m \\mathrm{e}^{\\mathrm{i}m\\varphi}}{r}\\begin{bmatrix} \\cos \\varphi \\cos \\theta\\\\sin \\varphi\\cos \\theta \\-\\sin\\theta \\end{bmatrix}. \\end{aligned} $ For the sake of simplicity, we incorporated the coefficient in of P_ell^m into the term P_ell^m itself.","category":"page"},{"location":"SH/","page":"-","title":"-","text":"To ensure numerically stable evaluation of gradients near sin theta = 0, we compute P_ell^msin theta instead of P_ell^m. We refer to section A.1 of Dusson(2022) for detailed discussion.","category":"page"},{"location":"SH/","page":"-","title":"-","text":"We can further compute nabla^2 Y_ell^m as,  $ \\begin{aligned} \\nabla^2 Y{\\ell m} = \\left(\\frac{1}{r^2}\\frac{\\partial}{\\partial r} r^2\\frac{\\partial}{\\partial r} - \\frac{L^2}{r^2}    \\right)Y{\\ell}^m = -\\frac{\\ell(\\ell+1)}{r^2}Y_{\\ell}^{m}. \\end{aligned} $ One can generate a data structure as ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"cylm = CYlmBasis(maxL::Integer, T::Type=Float64)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"The complex spherical harmonics allow for ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"P = evaluate(basis, X)\nP, dP = evaluate_ed(basis, X)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"To retrieve the specific values of Y_l^m and dY_l^m for given indices (l, m), one can use","category":"page"},{"location":"SH/","page":"-","title":"-","text":"index_y(l,m)","category":"page"},{"location":"SH/#Alternative-normalizations-conventions","page":"-","title":"Alternative normalizations conventions","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"Here, we provide a list of alternative normalizations conventions for complex spherical harmonics,","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Schmidt semi-normalized (Racah's normalization)","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} C{\\ell}^m(\\theta, \\varphi) = \\sqrt{\\frac{4\\pi}{2\\ell + 1}}Y{\\ell}^m(\\theta, \\varphi) = \\sqrt{\\frac{(\\ell-m)!}{(\\ell+m)!}}P{\\ell}^m(\\cos \\theta)\\mathrm{e}^{\\mathrm{i}m \\varphi},  \\end{aligned} $ with  $ \\begin{aligned} \\int0^{2\\pi}\\int0^{\\pi}C{k}^m(\\theta, \\varphi)\\bar{C}{\\ell}^n(\\theta, \\varphi)\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\varphi = \\frac{4\\pi}{2\\ell + 1}\\delta{k\\ell}\\delta{mn}.  \\end{aligned} $ In this normalization, C0^0(\\theta, \\varphi)$ is equal to 1. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"4π-normalized","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} \\mathscr{Y}{\\ell}^m (\\theta, \\varphi) = \\sqrt{4\\pi}Y{\\ell}^m(\\theta, \\varphi) = \\sqrt{(2\\ell+1)\\frac{(l-m)!}{(l+m)!}}P{\\ell}^m(\\cos \\theta)\\mathrm{e}^{\\mathrm{i}m \\varphi},  \\end{aligned} $ with  $ \\begin{aligned} \\int0^{2\\pi}\\int0^{\\pi}\\mathscr{Y}{k}^m(\\theta, \\varphi)\\bar{\\mathscr{Y}}{\\ell}^n(\\theta, \\varphi)\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\varphi = 4\\pi\\delta{k\\ell}\\delta_{mn}.  \\end{aligned} $","category":"page"},{"location":"SH/#Complex-Solid-Harmonics","page":"-","title":"Complex Solid Harmonics","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"In crlm.jl, Polynomials4ML utilizes orthonormalized complex solid harmonics defined as $ \\begin{aligned} \t\\gamma{\\ell}^m(r, \\theta, \\varphi) = r^{\\ell}Y{\\ell}^m(\\theta, \\varphi).  \\end{aligned} $ gamma_ell^m's are orthogonal is the sense that  $ \\begin{aligned} \t\\int0^{2\\pi}\\int0^{\\pi}\\gamma{k}^m(\\theta, \\varphi)\\bar{\\gamma}{\\ell}^n(\\theta, \\varphi)\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\varphi =\\delta{k\\ell}\\delta{mn}r^{k+\\ell}. \\end{aligned} $ The evaluation of solid harmonics can be obtained from the spherical harmonics by a simple scaling with r^ell.  To evaluate the gradients of the solid harmonics, nabla gamma_ell^m, the following expressions are used, $ \\begin{aligned} \\begin{cases} (\\frac{\\partial r}{\\partial x}, \\frac{\\partial r}{\\partial y}, \\frac{\\partial r}{\\partial z}) = (\\sin \\theta \\cos \\varphi,\\sin\\theta\\sin \\varphi, \\cos \\theta)\\\n(\\frac{\\partial \\varphi}{\\partial x}, \\frac{\\partial \\varphi}{\\partial y}, \\frac{\\partial \\varphi}{\\partial z}) = (-\\frac{\\sin\\varphi}{r\\sin \\theta}, \\frac{\\cos\\varphi}{r\\sin \\theta}, 0)\\\n(\\frac{\\partial \\theta}{\\partial x}, \\frac{\\partial \\theta}{\\partial y}, \\frac{\\partial \\theta}{\\partial z}) = (\\frac{\\cos \\varphi \\cos \\theta}{r}, \\frac{\\sin \\varphi \\cos \\theta}{r}, -\\frac{\\sin \\theta}{r}) \\end{cases}. \\end{aligned} $ Therefore, the gradient of gamma_ell^m can be expressed as, $ \\begin{aligned} \\nabla \\gamma{\\ell}^m = \\frac{\\ell r^{\\ell} P{\\ell}^m \\mathrm{e}^{\\mathrm{i}m\\varphi}}{r}\\begin{bmatrix} \\sin \\theta \\cos \\varphi\\ \\sin\\theta\\sin \\varphi\\ \\cos \\theta \\end{bmatrix}+ \\frac{\\mathrm{i}m P{\\ell}^m \\mathrm{e}^{\\mathrm{i}m\\varphi}}{r\\sin \\theta}\\begin{bmatrix} -\\sin \\varphi \\\\cos \\varphi \\0 \\end{bmatrix} +  \\frac{\\partial{\\theta}P{\\ell}^m \\mathrm{e}^{\\mathrm{i}m\\varphi}}{r}\\begin{bmatrix} \\cos \\varphi \\cos \\theta\\\\sin \\varphi\\cos \\theta \\-\\sin\\theta \\end{bmatrix}. \\end{aligned} $ Similarly, we incorporated the coefficient in of P{\\ell}^m$ into the term P_ell^m itself. We can further compute nabla^2 gamma_ell^m as,  $ \\begin{aligned} \\nabla^2 r^{\\ell}Y{\\ell m} = \\left(\\frac{1}{r^2}\\frac{\\partial}{\\partial r} r^2\\frac{\\partial}{\\partial r} - \\frac{L^2}{r^2}    \\right)r^{\\ell}Y{\\ell}^m = \\frac{Y{\\ell m}}{r^2}\\frac{\\partial}{\\partial r}r^2\\frac{\\partial r^{\\ell}}{\\partial r} - \\frac{r^{\\ell}L^2 Y{\\ell}^{m}}{r^2} = 0, \\end{aligned} $ that is, the solid harmonics are solutions to Laplace's equation. ","category":"page"},{"location":"SH/#Real-Spherical-Harmonics","page":"-","title":"Real Spherical Harmonics","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"In rylm.jl, Polynomials4ML utilizes orthonormalized real spherical harmonics that exclude the Condon-Shortley phase. ","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} Y{\\ell m}(\\theta, \\varphi) & =  \\begin{cases} \\frac{\\mathrm{i}}{\\sqrt{2}}(Y{\\ell}^m - (-1)^m Y{\\ell}^{-m}) & m < 0\\\nY{\\ell}^0 & m = 0 \\\n\\frac{1}{\\sqrt{2}}(Y{\\ell}^{-m} + (-1)^m Y{\\ell}^{m}) & m > 0 \\end{cases}\\\n& =  \\begin{cases} (-1)^m \\bar{P}{\\ell}^{|m|}(\\cos \\theta)\\sin(|m|\\varphi) & m < 0\\\n\\frac{1}{\\sqrt{2}} \\bar{P}{\\ell}^0(\\cos \\theta) & m = 0 \\\n(-1)^m \\bar{P}_{\\ell}^{m}(\\cos \\theta)\\cos(m\\varphi)  & m > 0 \\end{cases} \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} Y{\\ell m}(\\theta, \\varphi) & =  \\begin{cases} -\\bar{P}{\\ell}^{|m|}(\\cos \\theta)\\sin(|m|\\varphi) & m < 0\\\n\\frac{1}{\\sqrt{2}} \\bar{P}{\\ell}^0(\\cos \\theta) & m = 0 \\\n\\bar{P}{\\ell}^{m}(\\cos \\theta)\\cos(m\\varphi)  & m > 0 \\end{cases} \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Orthonormalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"-","title":"-","text":"mbackslashell 0 1 2 3\n3    frac14sqrtfrac352picdot fracx(x^2-3y^2)r^3\n2   frac14sqrtfrac15picdot fracx^2-y^2r^2 frac14sqrtfrac105picdot frac(x^2-y^2)zr^3\n1  sqrtfrac34picdot fracxr frac12sqrtfrac15picdot fraczxr^2 frac14sqrtfrac212picdot fracx(5z^2-r^2)r^3\n0 frac12sqrtfrac1pi sqrtfrac34picdot fraczr frac14sqrtfrac5picdot frac3z^2-r^2r^2 frac14sqrtfrac7picdot fracz(5z^2-3r^2)r^3\n-1  sqrtfrac34picdot fracyr frac12sqrtfrac15picdot fracyzr^2 frac14sqrtfrac212picdot fracy(5z^2-r^2)r^3\n-2   frac12sqrtfrac15picdot fracxyr^2 frac12sqrtfrac105picdot fracxyzr^2\n-3    frac14sqrtfrac352picdot frac(3x^2-y^2)yr^3","category":"page"},{"location":"SH/#Real-Solid-Harmonics","page":"-","title":"Real Solid Harmonics","text":"","category":"section"},{"location":"SH/","page":"-","title":"-","text":"In rrlm.jl, Polynomials4ML utilizes Schmidt semi-normalized real solid harmonics that exclude the Condon-Shortley phase.","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Include the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} S{\\ell m}(r, \\theta, \\varphi) & =  \\begin{cases} \\frac{\\mathbb{i}}{\\sqrt{2}}\\left(C{\\ell, m}-(-1)^m C{\\ell,-m} \\right) & m < 0\\\nC{10} & m = 0 \\\n \\frac{1}{\\sqrt{2}}\\left(C{\\ell, -m}+(-1)^m C{\\ell,m}\\right)  & m > 0 \\end{cases}\\\n& = \\begin{cases} (-1)^m \\sqrt{\\frac{4\\pi}{2l+1}}\\cdot r^{\\ell}\\bar{P}{\\ell}^{|m|}(\\cos \\theta)\\sin(|m|\\varphi) & m < 0\\\n\\sqrt{\\frac{2\\pi}{2l+1}}\\bar{P}{\\ell}^0(\\cos \\theta) & m = 0 \\\n(-1)^m \\sqrt{\\frac{4\\pi}{2l+1}}\\cdot r^{\\ell}\\bar{P}{\\ell}^{m}(\\cos \\theta)\\cos(m\\varphi)  & m > 0 \\end{cases}, \\end{aligned} $ where  $ \\begin{aligned} C{\\ell, m}(r, \\theta, \\varphi) = \\sqrt{\\frac{4\\pi}{2\\ell + 1}}\\gamma{\\ell}^m(\\theta, \\varphi),  \\end{aligned} $ with  $ \\begin{aligned} \\int0^{2\\pi}\\int0^{\\pi}C{k,m}(r, \\theta, \\varphi)\\bar{C}{\\ell, n}(r, \\theta, \\varphi)\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\varphi = \\frac{4\\pi}{2\\ell + 1}\\delta{k\\ell}\\delta_{mn} r^{k+\\ell}.  \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Exclude the Condon-Shortley phase factor:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"$","category":"page"},{"location":"SH/","page":"-","title":"-","text":"\\begin{aligned} S{\\ell m}(r, \\theta, \\varphi)  & =  \\begin{cases} -\\sqrt{\\frac{4\\pi}{2l+1}}\\cdot r^{\\ell}\\bar{P}{\\ell}^{|m|}(\\cos \\theta)\\sin(|m|\\varphi) & m < 0\\\n\\sqrt{\\frac{2\\pi}{2l+1}}\\bar{P}{\\ell}^0(\\cos \\theta) & m = 0 \\\n\\sqrt{\\frac{4\\pi}{2l+1}}\\cdot r^{\\ell}\\bar{P}{\\ell}^{m}(\\cos \\theta)\\cos(m\\varphi)  & m > 0 \\end{cases} \\end{aligned} $","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Schmidt semi-normalized real spherical harmonics that employ the Condon-Shortley phase up to degree ell = 3 are","category":"page"},{"location":"SH/","page":"-","title":"-","text":"mbackslashell 0 1 2 3\n3    frac12sqrtfrac52(x^2-3y^2)x\n2   frac12sqrt3(x^2-y^2) frac12sqrt15(x^2-y^2)z\n1  x sqrt3xz frac12sqrtfrac32(5z^2-r^2)x\n0 1 z frac12(3z^2-r^2) frac12(5z^2-3r^2)z\n-1  y sqrt3yz frac12sqrtfrac32(5z^2-r^2)y\n-2   sqrt3xy sqrt15xyz\n-3    frac12sqrtfrac52(3x^2-y^2)y","category":"page"},{"location":"SH/","page":"-","title":"-","text":"References:","category":"page"},{"location":"SH/","page":"-","title":"-","text":"Dusson, G., Bachmayr, M., Csányi, G., Drautz, R., Etter, S., van der Oord, C., & Ortner, C. (2022). Atomic cluster expansion: Completeness, efficiency and stability. Journal of Computational Physics, 454, 110946.\nHelgaker, T., Jorgensen, P., & Olsen, J. (2013). Molecular electronic-structure theory. John Wiley & Sons.\nLimpanuparb, T., & Milthorpe, J. (2014). Associated Legendre polynomials and spherical harmonics computation for chemistry applications. arXiv preprint arXiv:1410.1748.  \nWieczorek, M. A., & Meschede, M. (2018). SHTools: Tools for working with spherical harmonics. Geochemistry, Geophysics, Geosystems, 19(8), 2574-2592.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"CurrentModule = Polynomials4ML","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"This page lists all docstrings in Polynomials4ML including for functions that are not part of the public API. Please check with Public API which functionality is guaranteed semver-stable.","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"}]
}
